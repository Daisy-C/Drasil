-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Utils SubPackage
--   
--   Please see the README on GitHub at
--   <a>https://github.com/JacquesCarette/Drasil#readme</a>
@package drasil-utils
@version 0.1.1.0

module Utils.Drasil.Document

-- | Creates a blank document with no text.
blank :: Doc

-- | Indents a document (by 4 spaces).
indent :: Doc -> Doc

-- | Indents a list of Docs and combines into one Doc.
indentList :: [Doc] -> Doc

module Utils.Drasil.English

-- | String capitalization.
capitalize :: String -> String

-- | Comma separated list with "and" before final item.
stringList :: [String] -> String

module Utils.Drasil.Lists

-- | Replaces all elements of a target list that belong to a provided "bad"
--   input list.
replaceAll :: Eq a => [a] -> a -> [a] -> [a]

-- | Checks if the first set is a subset of the second.
subsetOf :: Eq a => [a] -> [a] -> Bool

module Utils.Drasil.Sentence

-- | Inserts the words "and its" between two Sentences.
andIts :: Sentence -> Sentence -> Sentence

-- | Inserts the words "and the" between two Sentences.
andThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "from the" between two Sentences.
fromThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "in the" between two Sentences.
inThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "on the" between two Sentences.
onThe :: Sentence -> Sentence -> Sentence

-- | Prepends "The" and inserts "is expected to have" between two
--   Sentences.
the_isExpctdToHvC :: Sentence -> Sentence -> Sentence

-- | Inserts the words "is the" between two Sentences.
isThe :: Sentence -> Sentence -> Sentence

-- | Prepends "the" and inserts "of a given" between two Sentences.
the_ofGiv :: Sentence -> Sentence -> Sentence

-- | Similar to <a>for</a>, but used for titles and first <a>NamedIdea</a>
--   is pluralized.
forTPS :: (NamedIdea c, NamedIdea d) => c -> d -> Sentence

-- | Similar to <tt>forTTPS</tt>, but both <a>NamedIdea</a>s are
--   pluralized.
forTPP :: (NamedIdea c, NamedIdea d) => c -> d -> Sentence

-- | Same as <tt>ofGiv</tt>, except first "the" is capitalized.
the_ofGivC :: Sentence -> Sentence -> Sentence

-- | Inserts the words "of the" between two Sentences.
ofThe :: Sentence -> Sentence -> Sentence

-- | Same as <a>ofThe</a>, but inserts "the" at the beginning of the
--   Sentence.
the_ofThe :: Sentence -> Sentence -> Sentence

-- | Same as <a>the_ofThe</a>, except first "the" is capitalized.
the_ofTheC :: Sentence -> Sentence -> Sentence

-- | Inserts the word "of" between two Sentences.
of_ :: Sentence -> Sentence -> Sentence

-- | Inserts the words "of a" between two Sentences.
ofA :: Sentence -> Sentence -> Sentence

-- | Inserts the word "or" between two Sentences.
or_ :: Sentence -> Sentence -> Sentence

-- | Inserts the word "versus" between two Sentences.
versus :: Sentence -> Sentence -> Sentence

-- | Inserts the word "and" between two Sentences.
and_ :: Sentence -> Sentence -> Sentence

-- | Inserts the word "are" between two Sentences.
are :: Sentence -> Sentence -> Sentence

-- | Inserts the word "in" between two Sentences.
in_ :: Sentence -> Sentence -> Sentence

-- | Inserts the word "is" between two Sentences.
is :: Sentence -> Sentence -> Sentence

-- | Inserts the words "to the" between two Sentences.
toThe :: Sentence -> Sentence -> Sentence

-- | Inserts the word "for" between two Sentences.
for :: Sentence -> Sentence -> Sentence

-- | Similar to <a>for</a>, but both terms are <a>titleize</a>d.
forT :: (NamedIdea c, NamedIdea d) => c -> d -> Sentence

-- | Similar to <tt>forTT</tt>, but takes two arguments (for capitalization
--   or pluralization) to apply to the two terms respectively.
forGen :: (c -> Sentence) -> (d -> Sentence) -> c -> d -> Sentence

-- | Inserts the words "denotes the" between two Sentences.
denotes :: Sentence -> Sentence -> Sentence

-- | Inserts the words "with respect to" between two Sentences.
wrt :: Sentence -> Sentence -> Sentence

-- | Inserts the words "defined as" between two Sentences.
defnAs :: Sentence -> Sentence -> Sentence

module Utils.Drasil.NounPhrase

-- | Helper function that places a <a>String</a> in between two <a>NP</a>s.
--   Plural case is <tt>(phraseNP t1) +:+ S s +:+ (pluralNP t2)</tt>.
insertString :: String -> NP -> NP -> NP

-- | Helper function that prepends a <a>String</a> to a <a>NP</a>.
prependString :: String -> NP -> NP

-- | Helper function that places a <a>Sentence</a> in between two
--   <a>NP</a>s. Plural case is <tt>(phraseNP t1) +:+ s +:+ (pluralNP
--   t2)</tt>.
insertSent :: Sentence -> NP -> NP -> NP

-- | Helper function that prepends a <a>Sentence</a> to a <a>NP</a>.
prependSent :: Sentence -> NP -> NP

-- | Prepends "the" to a <a>NP</a>.
the :: NP -> NP

-- | Similar to <a>the</a>, but accepts a function that determines the
--   plural case.
theGen :: (NP -> Sentence) -> NP -> NP

-- | Prepends "a" to a <a>NP</a>.
a_ :: NP -> NP

-- | Similar to <tt>a</tt>, but accepts a function that determines the
--   plural case.
a_Gen :: (NP -> Sentence) -> NP -> NP

-- | Inserts "of the" between two <a>NP</a>s. Plural case is <tt>(phraseNP
--   t1) +:+ "of the" +:+ (pluralNP t2)</tt>.
ofThe :: NP -> NP -> NP

-- | Similar to <a>ofThe</a>, but the plural case is now <tt>(pluralNP t1)
--   <a>ofThe</a> (phraseNP t2)</tt>.
ofThePS :: NP -> NP -> NP

-- | Similar to <a>ofThe</a>, but accepts two functions for the plural
--   case.
ofTheGen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "in the" between two <a>NP</a>s. Plural case is <tt>(phraseNP
--   t1) +:+ "in the" +:+ (pluralNP t2)</tt>.
inThe :: NP -> NP -> NP

-- | Similar to <a>ofThe</a>, but the plural case is now <tt>(pluralNP t1)
--   <a>inThe</a> (phraseNP t2)</tt>.
inThePS :: NP -> NP -> NP

-- | Similar to <a>ofThe</a>, but accepts two functions for the plural
--   case.
inTheGen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Prepends "the" and inserts "of the". Plural case is <tt>"the" +:+
--   (phraseNP t1) +:+ "of the" +:+ (pluralNP t2)</tt>.
the_ofThe :: NP -> NP -> NP

-- | Similar to <a>the_ofThe</a>, but the plural case is now <tt> S "the"
--   +:+ (pluralNP t1) <a>ofThe</a> (phraseNP t2)</tt>.
the_ofThePS :: NP -> NP -> NP

-- | Similar to <tt>the_ofThe'</tt>, but takes two functions for the plural
--   case.
the_ofTheGen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "for" between two <a>NP</a>s. Plural case is <tt>(phraseNP t1)
--   +:+ "for" +:+ (pluralNP t2)</tt>.
for :: NP -> NP -> NP

-- | Same as <a>for</a>, but plural case is now <tt>(pluralNP t1)
--   <a>for</a> (phraseNP t2)</tt>.
forPS :: NP -> NP -> NP

-- | Same as <tt>for'</tt>, but takes two functions for the plural case.
forGen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "of" between two <a>NP</a>s. Plural case is <tt>(phraseNP t1)
--   +:+ "of" +:+ (pluralNP t2)</tt>.
of_ :: NP -> NP -> NP

-- | Same as <a>of_</a>, but plural case is now <tt>(pluralNP t1)
--   <a>of_</a> (phraseNP t2)</tt>.
of_PS :: NP -> NP -> NP

-- | Same as <a>of_</a>, but takes two functions for the plural case.
of_Gen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Same as <a>of_</a>, but takes two functions for the singular case and
--   two for the plural case.
of_GenGen :: (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "with" between two <a>NP</a>s. Plural case is <tt>(phraseNP
--   t1) +:+ "with" +:+ (pluralNP t2)</tt>.
with :: NP -> NP -> NP

-- | Inserts "and" between two <a>NP</a>s. Plural case is <tt>(phraseNP t1)
--   +:+ "and" +:+ (pluralNP t2)</tt>.
and_ :: NP -> NP -> NP

-- | Same as <a>and_</a>, but plural case is now <tt>(pluralNP t1)
--   <a>and_</a> (phraseNP t2)</tt>.
and_PS :: NP -> NP -> NP

-- | Same as <a>and_</a>, but takes two functions for the plural case.
and_Gen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Same as <a>and_</a>, but takes two functions for the singular case and
--   two for the plural case.
and_GenGen :: (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "and the" between two <a>NP</a>s. Plural case is <tt>(phraseNP
--   t1) +:+ "and the" +:+ (pluralNP t2)</tt>.
andThe :: NP -> NP -> NP

module Utils.Drasil.Fold

-- | Type that helps determine enumeration method. Can use either numbers,
--   uppercase letters, or lowercase letters.
data EnumType
Numb :: EnumType
Upper :: EnumType
Lower :: EnumType

-- | Type to help wrap a sentence with parenthesis or to add a period at
--   the end.
data WrapType
Parens :: WrapType
Period :: WrapType

-- | Type to help separate words with commas or semicolons.
data SepType
Comma :: SepType
SemiCol :: SepType

-- | Type to help fold differently between listed items, or if there are
--   options (ex. using "and" or "or" at the end of a list of words).
data FoldType
List :: FoldType
Options :: FoldType

-- | Helper for formatting constraints.
foldConstraints :: Quantity c => c -> [ConstraintE] -> Sentence

-- | Creates a list of elements with "enumerators" in "wrappers" using
--   foldlList.
foldlEnumList :: EnumType -> WrapType -> SepType -> FoldType -> [Sentence] -> Sentence

-- | Creates a list of elements separated by a "separator", ending with
--   "and" or "or".
foldlList :: SepType -> FoldType -> [Sentence] -> Sentence

-- | Fold sentences then turns into content using <a>foldlSent</a>.
foldlSP :: [Sentence] -> Contents

-- | Same as <a>foldlSP</a> but uses <a>foldlSent_</a>.
foldlSP_ :: [Sentence] -> Contents

-- | Same as <a>foldlSP</a> but uses <a>foldlSentCol</a>.
foldlSPCol :: [Sentence] -> Contents

-- | Partial function application of foldle for sentences specifically.
--   folds with spaces and adds "." at the end.
foldlSent :: [Sentence] -> Sentence

-- | <a>foldlSent</a> but does not end with period.
foldlSent_ :: [Sentence] -> Sentence

-- | <a>foldlSent</a> but ends with colon.
foldlSentCol :: [Sentence] -> Sentence

-- | Folds a list of elements separated by commas, including the last
--   element.
foldlsC :: [Sentence] -> Sentence

-- | Parses a list of integers into a nice sentence (ie. S "1, 4-7, and
--   13").
foldNums :: String -> [Int] -> Sentence

-- | Parses a list of integers into a list of strings (ie. ["1", "4-7",
--   "13"]).
numList :: String -> [Int] -> [String]

module Utils.Drasil.Misc

-- | Converts input to a <a>Sentence</a> and appends %.
addPercent :: Show a => a -> Sentence

-- | Applies <a>Bullet</a> and <a>Flat</a> to a list.
bulletFlat :: [Sentence] -> ListType

-- | Applies <a>Bullet</a>s and headers to a <a>Nested</a> <a>ListType</a>.
--   The first argument is the headers of the <a>Nested</a> lists.
bulletNested :: [Sentence] -> [ListType] -> ListType

-- | Uses an <a>Either</a> type to check if a <a>String</a> is valid -
--   <a>Left</a> with error message if there is an invalid <a>Char</a> in
--   <a>String</a>, else <a>Right</a> with <a>String</a>.
checkValidStr :: String -> String -> Either String String

-- | Output is of the form "<tt>reference - sentence</tt>".
chgsStart :: (HasShortName x, Referable x) => x -> Sentence -> Sentence

-- | Takes a <a>HasSymbol</a> that is also <a>Referable</a> and outputs as
--   a <a>Sentence</a>: "<tt>symbol</tt> is defined in <tt>reference</tt>."
definedIn :: (Referable r, HasShortName r, HasSymbol r) => r -> Sentence

-- | Same as <a>definedIn</a>, but allows for additional information to be
--   appended to the <a>Sentence</a>.
definedIn' :: (Referable r, HasShortName r, HasSymbol r) => r -> Sentence -> Sentence

-- | Takes a <a>Referable</a> and outputs as a <a>Sentence</a> "defined in
--   <tt>reference</tt>" (no <a>HasSymbol</a>).
definedIn'' :: (Referable r, HasShortName r) => r -> Sentence

-- | Takes a <a>Symbol</a> and its <a>Reference</a> (does not append a
--   period at the end!). Outputs as "<tt>symbol</tt> is defined in
--   <tt>source</tt>".
definedIn''' :: (HasSymbol q, HasUID q, Referable r, HasShortName r) => q -> r -> Sentence

-- | Produces a <a>Sentence</a> that displays the constraints in a set {}.
displayStrConstrntsAsSet :: Quantity a => a -> [String] -> Sentence

-- | Produces a <a>Sentence</a> that displays the constraints in a set {}.
displayDblConstrntsAsSet :: Quantity a => a -> [Double] -> Sentence

-- | Prepends the word <a>Equation</a> to an <a>Int</a>.
eqN :: Int -> Sentence

-- | Takes an expression and a <a>Referable</a> and outputs as a Sentence
--   "expression (source)".
eqnWSource :: (Display e, Referable r, HasShortName r) => e -> r -> Sentence

-- | Takes a <a>Referable</a> source and a <a>UnitalChunk</a> and outputs
--   as a <a>Sentence</a>: "From <tt>source</tt> we can replace
--   <tt>symbol</tt>:".
fromReplace :: (Referable r, HasShortName r) => r -> UnitalChunk -> Sentence

-- | Wraps "from <tt>reference</tt>" in parentheses.
fromSource :: (Referable r, HasShortName r) => r -> Sentence

-- | Similar to <a>fromSource</a> but takes a list of references instead of
--   one.
fromSources :: (Referable r, HasShortName r) => [r] -> Sentence

-- | Takes an amount as a <a>Sentence</a> and appends a unit to it.
fmtU :: MayHaveUnit a => Sentence -> a -> Sentence

-- | Appends "following <tt>reference</tt>" to the end of a
--   <a>Sentence</a>.
follows :: (Referable r, HasShortName r) => Sentence -> r -> Sentence

-- | Used when you want to say a term followed by its symbol. ex. "...using
--   the Force F in...".
getTandS :: Quantity a => a -> Sentence

-- | Makes <a>Sentence</a>s from an item and its reference. Takes the title
--   of reference as a <a>String</a> and a <a>Sentence</a> containing the
--   full reference. Wraps the full reference in parenthesis.
itemRefToSent :: String -> Sentence -> Sentence

-- | Takes a list and a reference, then generates references to match the
--   length of the list.
makeListRef :: [a] -> Section -> [Sentence]

-- | Makes a traceability matrix from a list of row titles, a list of rows
--   of "checked" columns, and a list of columns.
makeTMatrix :: Eq a => [Sentence] -> [[a]] -> [a] -> [[Sentence]]

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeChanged :: Sentence -> Sentence -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeExpanded :: Sentence -> Sentence -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeWOVerb :: Sentence -> Sentence -> Sentence

-- | Zip helper function enumerates abbreviations and zips it with list of
--   <a>ItemType</a>:
--   
--   <ul>
--   <li>s - the number from which the enumeration should start from
--   (<a>Integer</a>),</li>
--   <li>t - the title of the list (<a>Sentence</a>),</li>
--   <li>l - the list to be enumerated ([<a>Sentence</a>]).</li>
--   </ul>
mkEnumAbbrevList :: Integer -> Sentence -> [Sentence] -> [(Sentence, ItemType)]

-- | Helper for making a table from a columns.
mkTableFromColumns :: [(Sentence, [Sentence])] -> ([Sentence], [[Sentence]])

-- | Converts lists of simple <a>ItemType</a>s into a list which may be
--   used in <a>Contents</a> but is not directly referable.
noRefs :: [ItemType] -> [(ItemType, Maybe String)]

-- | Create a list in the pattern of "The __ are refined to the __". Note:
--   Order matters!
refineChain :: NamedIdea c => [(c, Section)] -> Sentence

-- | Returns the <a>Sentence</a> "<tt>(<a>titleize</a> aNamedIdea)</tt>
--   Showing the Connections Between <tt>contents</tt>".
showingCxnBw :: NamedIdea c => c -> Sentence -> Sentence

-- | Sorts a list of <tt>HasSymbols</tt> by Symbol.
sortBySymbol :: HasSymbol a => [a] -> [a]

-- | Sorts a tuple list of <tt>HasSymbols</tt> by first Symbol in the
--   tuple.
sortBySymbolTuple :: HasSymbol a => [(a, b)] -> [(a, b)]

-- | Takes a list of <a>Referable</a>s and <a>Symbol</a>s and outputs as a
--   Sentence "By substituting <tt>symbols</tt>, this can be written as:".
substitute :: (Referable r, HasShortName r, HasSymbol r) => [r] -> Sentence

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term -
--   termDefinition</tt>".
tAndDOnly :: Concept s => s -> ItemType

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term (abbreviation) -
--   termDefinition</tt>".
tAndDWAcc :: Concept s => s -> ItemType

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term (symbol) -
--   termDefinition</tt>".
tAndDWSym :: (Concept s, Quantity a) => s -> a -> ItemType

-- | Extracts the typical uncertainty to be displayed from something that
--   has an uncertainty.
typUncr :: HasUncertainty c => c -> Sentence

-- | Returns the <a>Sentence</a> "The <tt>chunk</tt> under consideration is
--   <tt>chunkDefinition</tt>".
underConsidertn :: ConceptChunk -> Sentence

-- | Get a unit symbol if there is one.
unwrap :: Maybe UnitDefn -> Sentence

-- | Interweaves two lists together <tt>[[a,b,c],[d,e,f]] -&gt;
--   [a,d,b,e,c,f]</tt>.
weave :: [[a]] -> [a]

-- | Distributes a list of Sentences by prepending individual Sentences
--   once to an existing list of Sentences.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; zipSentList [S "Hi", S "Hey", S "Hi"] [[S"Hello"], [S"World"], [S"Hello", S"World]]
--   [[S "Hi", S"Hello"], [S "Hey", S"World"], [S "Hi", S"Hello", S"World]]
--   </pre>
zipSentList :: [[Sentence]] -> [Sentence] -> [[Sentence]] -> [[Sentence]]

-- | Apply a binary function to the terms of two named ideas, instead of to
--   the named ideas themselves. Ex. <tt>fterms compoundPhrase t1 t2</tt>
--   instead of <tt>compoundPhrase (t1 ^. term) (t2 ^. term)</tt>.
fterms :: (NamedIdea c, NamedIdea d) => (NP -> NP -> t) -> c -> d -> t

module Utils.Drasil.Contents

-- | Applies <a>Enumeration</a>, <a>Bullet</a> and <a>Flat</a> to a list.
enumBullet :: Reference -> [Sentence] -> LabelledContent

-- | Same as <a>enumBullet</a> but unlabelled.
enumBulletU :: [Sentence] -> Contents

-- | Enumerates a list and applies <a>Simple</a> and <a>Enumeration</a> to
--   it:
--   
--   <ul>
--   <li>lb - Reference,</li>
--   <li>s - start index for the enumeration,</li>
--   <li>t - title of the list,</li>
--   <li>l - list to be enumerated.</li>
--   </ul>
enumSimple :: Reference -> Integer -> Sentence -> [Sentence] -> LabelledContent

-- | Same as <a>enumSimple</a> but unlabelled.
enumSimpleU :: Integer -> Sentence -> [Sentence] -> Contents

-- | Constructs <a>LabelledContent</a> from an expression and a reference.
lbldExpr :: Display c => c -> Reference -> LabelledContent

-- | Same as <tt>eqUnR</tt> except content is unlabelled.
unlbldExpr :: Display c => c -> Contents

-- | Convenience function for transforming types which are instances of the
--   constraints <a>Referable</a>, <a>HasShortName</a>, and
--   <a>Definition</a>, into Simple-type <a>Enumeration</a>s.
mkEnumSimpleD :: (Referable c, HasShortName c, Definition c) => [c] -> [Contents]

module Utils.Drasil

-- | Applies <a>Enumeration</a>, <a>Bullet</a> and <a>Flat</a> to a list.
enumBullet :: Reference -> [Sentence] -> LabelledContent

-- | Same as <a>enumBullet</a> but unlabelled.
enumBulletU :: [Sentence] -> Contents

-- | Enumerates a list and applies <a>Simple</a> and <a>Enumeration</a> to
--   it:
--   
--   <ul>
--   <li>lb - Reference,</li>
--   <li>s - start index for the enumeration,</li>
--   <li>t - title of the list,</li>
--   <li>l - list to be enumerated.</li>
--   </ul>
enumSimple :: Reference -> Integer -> Sentence -> [Sentence] -> LabelledContent

-- | Same as <a>enumSimple</a> but unlabelled.
enumSimpleU :: Integer -> Sentence -> [Sentence] -> Contents

-- | Convenience function for transforming types which are instances of the
--   constraints <a>Referable</a>, <a>HasShortName</a>, and
--   <a>Definition</a>, into Simple-type <a>Enumeration</a>s.
mkEnumSimpleD :: (Referable c, HasShortName c, Definition c) => [c] -> [Contents]

-- | Constructs <a>LabelledContent</a> from an expression and a reference.
lbldExpr :: Display c => c -> Reference -> LabelledContent

-- | Same as <tt>eqUnR</tt> except content is unlabelled.
unlbldExpr :: Display c => c -> Contents

-- | Creates a blank document with no text.
blank :: Doc

-- | Indents a document (by 4 spaces).
indent :: Doc -> Doc

-- | Indents a list of Docs and combines into one Doc.
indentList :: [Doc] -> Doc

-- | String capitalization.
capitalize :: String -> String

-- | Comma separated list with "and" before final item.
stringList :: [String] -> String

-- | Type that helps determine enumeration method. Can use either numbers,
--   uppercase letters, or lowercase letters.
data EnumType
Numb :: EnumType
Upper :: EnumType
Lower :: EnumType

-- | Type to help wrap a sentence with parenthesis or to add a period at
--   the end.
data WrapType
Parens :: WrapType
Period :: WrapType

-- | Type to help separate words with commas or semicolons.
data SepType
Comma :: SepType
SemiCol :: SepType

-- | Type to help fold differently between listed items, or if there are
--   options (ex. using "and" or "or" at the end of a list of words).
data FoldType
List :: FoldType
Options :: FoldType

-- | Helper for formatting constraints.
foldConstraints :: Quantity c => c -> [ConstraintE] -> Sentence

-- | Creates a list of elements with "enumerators" in "wrappers" using
--   foldlList.
foldlEnumList :: EnumType -> WrapType -> SepType -> FoldType -> [Sentence] -> Sentence

-- | Creates a list of elements separated by a "separator", ending with
--   "and" or "or".
foldlList :: SepType -> FoldType -> [Sentence] -> Sentence

-- | Fold sentences then turns into content using <a>foldlSent</a>.
foldlSP :: [Sentence] -> Contents

-- | Same as <a>foldlSP</a> but uses <a>foldlSent_</a>.
foldlSP_ :: [Sentence] -> Contents

-- | Same as <a>foldlSP</a> but uses <a>foldlSentCol</a>.
foldlSPCol :: [Sentence] -> Contents

-- | Partial function application of foldle for sentences specifically.
--   folds with spaces and adds "." at the end.
foldlSent :: [Sentence] -> Sentence

-- | <a>foldlSent</a> but does not end with period.
foldlSent_ :: [Sentence] -> Sentence

-- | <a>foldlSent</a> but ends with colon.
foldlSentCol :: [Sentence] -> Sentence

-- | Folds a list of elements separated by commas, including the last
--   element.
foldlsC :: [Sentence] -> Sentence

-- | Parses a list of integers into a nice sentence (ie. S "1, 4-7, and
--   13").
foldNums :: String -> [Int] -> Sentence

-- | Parses a list of integers into a list of strings (ie. ["1", "4-7",
--   "13"]).
numList :: String -> [Int] -> [String]

-- | Replaces all elements of a target list that belong to a provided "bad"
--   input list.
replaceAll :: Eq a => [a] -> a -> [a] -> [a]

-- | Checks if the first set is a subset of the second.
subsetOf :: Eq a => [a] -> [a] -> Bool

-- | Converts input to a <a>Sentence</a> and appends %.
addPercent :: Show a => a -> Sentence

-- | Applies <a>Bullet</a> and <a>Flat</a> to a list.
bulletFlat :: [Sentence] -> ListType

-- | Applies <a>Bullet</a>s and headers to a <a>Nested</a> <a>ListType</a>.
--   The first argument is the headers of the <a>Nested</a> lists.
bulletNested :: [Sentence] -> [ListType] -> ListType

-- | Uses an <a>Either</a> type to check if a <a>String</a> is valid -
--   <a>Left</a> with error message if there is an invalid <a>Char</a> in
--   <a>String</a>, else <a>Right</a> with <a>String</a>.
checkValidStr :: String -> String -> Either String String

-- | Output is of the form "<tt>reference - sentence</tt>".
chgsStart :: (HasShortName x, Referable x) => x -> Sentence -> Sentence

-- | Takes a <a>HasSymbol</a> that is also <a>Referable</a> and outputs as
--   a <a>Sentence</a>: "<tt>symbol</tt> is defined in <tt>reference</tt>."
definedIn :: (Referable r, HasShortName r, HasSymbol r) => r -> Sentence

-- | Same as <a>definedIn</a>, but allows for additional information to be
--   appended to the <a>Sentence</a>.
definedIn' :: (Referable r, HasShortName r, HasSymbol r) => r -> Sentence -> Sentence

-- | Takes a <a>Referable</a> and outputs as a <a>Sentence</a> "defined in
--   <tt>reference</tt>" (no <a>HasSymbol</a>).
definedIn'' :: (Referable r, HasShortName r) => r -> Sentence

-- | Takes a <a>Symbol</a> and its <a>Reference</a> (does not append a
--   period at the end!). Outputs as "<tt>symbol</tt> is defined in
--   <tt>source</tt>".
definedIn''' :: (HasSymbol q, HasUID q, Referable r, HasShortName r) => q -> r -> Sentence

-- | Produces a <a>Sentence</a> that displays the constraints in a set {}.
displayStrConstrntsAsSet :: Quantity a => a -> [String] -> Sentence

-- | Produces a <a>Sentence</a> that displays the constraints in a set {}.
displayDblConstrntsAsSet :: Quantity a => a -> [Double] -> Sentence

-- | Prepends the word <a>Equation</a> to an <a>Int</a>.
eqN :: Int -> Sentence

-- | Takes an expression and a <a>Referable</a> and outputs as a Sentence
--   "expression (source)".
eqnWSource :: (Display e, Referable r, HasShortName r) => e -> r -> Sentence

-- | Takes a <a>Referable</a> source and a <a>UnitalChunk</a> and outputs
--   as a <a>Sentence</a>: "From <tt>source</tt> we can replace
--   <tt>symbol</tt>:".
fromReplace :: (Referable r, HasShortName r) => r -> UnitalChunk -> Sentence

-- | Wraps "from <tt>reference</tt>" in parentheses.
fromSource :: (Referable r, HasShortName r) => r -> Sentence

-- | Similar to <a>fromSource</a> but takes a list of references instead of
--   one.
fromSources :: (Referable r, HasShortName r) => [r] -> Sentence

-- | Takes an amount as a <a>Sentence</a> and appends a unit to it.
fmtU :: MayHaveUnit a => Sentence -> a -> Sentence

-- | Appends "following <tt>reference</tt>" to the end of a
--   <a>Sentence</a>.
follows :: (Referable r, HasShortName r) => Sentence -> r -> Sentence

-- | Used when you want to say a term followed by its symbol. ex. "...using
--   the Force F in...".
getTandS :: Quantity a => a -> Sentence

-- | Makes <a>Sentence</a>s from an item and its reference. Takes the title
--   of reference as a <a>String</a> and a <a>Sentence</a> containing the
--   full reference. Wraps the full reference in parenthesis.
itemRefToSent :: String -> Sentence -> Sentence

-- | Takes a list and a reference, then generates references to match the
--   length of the list.
makeListRef :: [a] -> Section -> [Sentence]

-- | Makes a traceability matrix from a list of row titles, a list of rows
--   of "checked" columns, and a list of columns.
makeTMatrix :: Eq a => [Sentence] -> [[a]] -> [a] -> [[Sentence]]

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeChanged :: Sentence -> Sentence -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeExpanded :: Sentence -> Sentence -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeWOVerb :: Sentence -> Sentence -> Sentence

-- | Zip helper function enumerates abbreviations and zips it with list of
--   <a>ItemType</a>:
--   
--   <ul>
--   <li>s - the number from which the enumeration should start from
--   (<a>Integer</a>),</li>
--   <li>t - the title of the list (<a>Sentence</a>),</li>
--   <li>l - the list to be enumerated ([<a>Sentence</a>]).</li>
--   </ul>
mkEnumAbbrevList :: Integer -> Sentence -> [Sentence] -> [(Sentence, ItemType)]

-- | Helper for making a table from a columns.
mkTableFromColumns :: [(Sentence, [Sentence])] -> ([Sentence], [[Sentence]])

-- | Converts lists of simple <a>ItemType</a>s into a list which may be
--   used in <a>Contents</a> but is not directly referable.
noRefs :: [ItemType] -> [(ItemType, Maybe String)]

-- | Create a list in the pattern of "The __ are refined to the __". Note:
--   Order matters!
refineChain :: NamedIdea c => [(c, Section)] -> Sentence

-- | Returns the <a>Sentence</a> "<tt>(<a>titleize</a> aNamedIdea)</tt>
--   Showing the Connections Between <tt>contents</tt>".
showingCxnBw :: NamedIdea c => c -> Sentence -> Sentence

-- | Sorts a list of <tt>HasSymbols</tt> by Symbol.
sortBySymbol :: HasSymbol a => [a] -> [a]

-- | Sorts a tuple list of <tt>HasSymbols</tt> by first Symbol in the
--   tuple.
sortBySymbolTuple :: HasSymbol a => [(a, b)] -> [(a, b)]

-- | Takes a list of <a>Referable</a>s and <a>Symbol</a>s and outputs as a
--   Sentence "By substituting <tt>symbols</tt>, this can be written as:".
substitute :: (Referable r, HasShortName r, HasSymbol r) => [r] -> Sentence

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term -
--   termDefinition</tt>".
tAndDOnly :: Concept s => s -> ItemType

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term (abbreviation) -
--   termDefinition</tt>".
tAndDWAcc :: Concept s => s -> ItemType

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term (symbol) -
--   termDefinition</tt>".
tAndDWSym :: (Concept s, Quantity a) => s -> a -> ItemType

-- | Extracts the typical uncertainty to be displayed from something that
--   has an uncertainty.
typUncr :: HasUncertainty c => c -> Sentence

-- | Returns the <a>Sentence</a> "The <tt>chunk</tt> under consideration is
--   <tt>chunkDefinition</tt>".
underConsidertn :: ConceptChunk -> Sentence

-- | Get a unit symbol if there is one.
unwrap :: Maybe UnitDefn -> Sentence

-- | Interweaves two lists together <tt>[[a,b,c],[d,e,f]] -&gt;
--   [a,d,b,e,c,f]</tt>.
weave :: [[a]] -> [a]

-- | Distributes a list of Sentences by prepending individual Sentences
--   once to an existing list of Sentences.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; zipSentList [S "Hi", S "Hey", S "Hi"] [[S"Hello"], [S"World"], [S"Hello", S"World]]
--   [[S "Hi", S"Hello"], [S "Hey", S"World"], [S "Hi", S"Hello", S"World]]
--   </pre>
zipSentList :: [[Sentence]] -> [Sentence] -> [[Sentence]] -> [[Sentence]]

-- | Apply a binary function to the terms of two named ideas, instead of to
--   the named ideas themselves. Ex. <tt>fterms compoundPhrase t1 t2</tt>
--   instead of <tt>compoundPhrase (t1 ^. term) (t2 ^. term)</tt>.
fterms :: (NamedIdea c, NamedIdea d) => (NP -> NP -> t) -> c -> d -> t

module Utils.Drasil.Concepts

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "and" between their terms. Plural case is <tt>(phrase t1) "and"
--   (plural t2)</tt>.
and_ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "and" between their terms. Plural case is <tt>(plural t1) "and"
--   (phrase t2)</tt>.
and_PS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "and" between their terms. Plural case is <tt>(plural t1) "and"
--   (plural t2)</tt>.
and_PP :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Customizable <a>and_</a> combinator (takes two title case
--   capitalization rules and two <tt>NamedIdeas</tt>).
and_TGen :: (NamedIdea c, NamedIdea d) => (c -> Sentence) -> (d -> Sentence) -> c -> d -> NP

-- | Customizable <a>and_</a> combinator. Both plural and singular cases
--   are dermined by the two given functions
and_Gen :: (c -> Sentence) -> (d -> Sentence) -> c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "and its" between their terms. Plural case is <tt>(phrase t1) "and
--   its" (plural t2)</tt>.
andIts :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "and the" between their terms. Plural case is <tt>(phrase t1) "and
--   the" (plural t2)</tt>.
andThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Case with "T1s with T2", as opposed to "T1 with T2", i.e. singular
--   case is <tt>(plural t1) "with" (phrase t2)</tt> while the plural case
--   pluralizes the first.
with :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "of" between their terms. Plural case is <tt>(phrase t1) "of" (plural
--   t2)</tt>.
of_ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a> but second argument is a <a>NounPhrase</a>.
of_NINP :: (NamedIdea c, NounPhrase d) => c -> d -> NP

-- | Same as <a>of_</a> but first argument is a <a>NounPhrase</a> and
--   plural case is <tt>(plural t1) "of" (phrase t2)</tt>.
of_PSNPNI :: (NounPhrase c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a>, except plural case is <tt>(plural t1) "of" (phrase
--   t2)</tt>.
of_PS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_PS</a>, except combining <a>Sentence</a> piece is "of
--   a".
ofA :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>ofA</a>, except phrase case is <tt>(plural t1) "of a"
--   (phrase t2)</tt>.
ofAPS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a>, except combining <a>Sentence</a> piece is "of
--   the". Plural case is <tt>(phrase t1) <a>ofThe</a> (plural t2)</tt>.
ofThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>ofThe</a>, except plural case is <tt>(plural t1)
--   <a>ofThe</a> (phrase t2)</tt>.
ofThePS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>ofThe</a>, except prepends "the".
the_ofThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>the_ofThe</a>, except plural case is <tt>(plural t1)
--   <a>the_ofThe</a> (phrase t2)</tt>
the_ofThePS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a>, except combining Sentence piece is "on the".
onThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>onThe</a>, except plural case is (plural t1) S.onThe
--   (phrase t2)
onThePS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "in the" between their terms. Plural case is <tt>(phrase t1) "in the"
--   (plural t2)</tt>.
inThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "in the" between their terms. Plural case is <tt>(plural t1) "in the"
--   (phrase t2)</tt>.
inThePS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "is the" between their terms. Plural case is <tt>(phrase t1) "is the"
--   (plural t2)</tt>.
isThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "to the" between their terms. Plural case is <tt>(phrase t1) "to the"
--   (plural t2)</tt>.
toThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "for" between their terms. Plural case is <tt>(phrase t1) "for"
--   (plural t2)</tt>.
for :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Similar to <a>for</a>, but takes two functions that determine the
--   <a>titleCase</a>.
forTGen :: (NamedIdea c, Idea d) => (c -> Sentence) -> (d -> Sentence) -> c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "in" between their terms. Plural case is <tt>(phrase t1) "in" (plural
--   t2)</tt>.
in_ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>in_</a>, except plural case is <tt>(plural t1) "in" (phrase
--   t2)</tt>.
in_PS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "in a" between their terms. Plural case is <tt>(phrase t1) "in a"
--   (plural t2)</tt>.
inA :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "is" between their terms. Plural case is <tt>(phrase t1) "is" (plural
--   t2)</tt>.
is :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Prepends "the" to a <a>NamedIdea</a>.
the :: NamedIdea t => t -> NP

-- | A customizable version of <a>the</a>. The given function is applied to
--   both singular and plural cases.
theGen :: (t -> Sentence) -> t -> NP

-- | Prepends "a" to a <a>NamedIdea</a> (similar to <a>the</a>).
a_ :: NamedIdea c => c -> NP

-- | Customizable version of <tt>a</tt>.
a_Gen :: (c -> Sentence) -> c -> NP

-- | Combinator for combining two <tt>NamedIdeas</tt>s into a
--   <a>NamedChunk</a>. Plural case only makes second term plural. See
--   <a>compoundPhrase</a> for more on plural behaviour. <i>Does not
--   preserve abbreviations</i>.
compoundNC :: (NamedIdea a, NamedIdea b) => a -> b -> NamedChunk

-- | Similar to <a>compoundNC</a> but both terms are pluralized for plural
--   case.
compoundNCPP :: (NamedIdea a, NamedIdea b) => a -> b -> NamedChunk

-- | Similar to <a>compoundNC</a>, except plural cases are customizable.
compoundNCGen :: (NamedIdea a, NamedIdea b) => (NP -> Sentence) -> (NP -> Sentence) -> a -> b -> NamedChunk

-- | Similar to <a>compoundNC</a>, except for plural case, where first
--   parameter gets pluralized while second one stays singular.
compoundNCPS :: NamedChunk -> NamedChunk -> NamedChunk

-- | Similar to <a>compoundNCGenP</a> but sets first parameter function to
--   plural.
compoundNCPSPP :: NamedChunk -> NamedChunk -> NamedChunk

-- | Similar to <a>compoundNC</a>, but takes a function that is applied to
--   the first term (eg. <a>short</a> or <a>plural</a>).
compoundNCGenP :: (NamedIdea a, NamedIdea b) => (NP -> Sentence) -> a -> b -> NamedChunk

-- | Helper function that combines a <a>NamedIdea</a> and a <a>NP</a>
--   without any words in between. Plural case is <tt>(phrase t1) +:+
--   (pluralNP t2)</tt>.
combineNINP :: NamedIdea c => c -> NP -> NP

-- | Similar to <a>combineNINP</a> but takes in a <a>NP</a> first and a
--   <a>NamedIdea</a> second.
combineNPNI :: NamedIdea c => NP -> c -> NP

-- | Similar to <a>combineNINP</a> but takes two <a>NamedIdea</a>s.
combineNINI :: (NamedIdea c, NamedIdea d) => c -> d -> NP

module Utils.Drasil.Strings

-- | Replace occurences of special characters
--   (",~`-=!@#$%^&amp;*+[]\;'/|"&lt;&gt;? ") with underscores ("_").
toPlainName :: String -> String

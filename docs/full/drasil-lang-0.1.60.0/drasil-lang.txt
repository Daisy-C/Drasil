-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Language SubPackage
--   
--   Please see the README on GitHub at
--   <a>https://github.com/JacquesCarette/Drasil#readme</a>
@package drasil-lang
@version 0.1.60.0


-- | Custom type for dates, in this case Month. This should, in time, be
--   switched out in favour of a proper package designed to handle all the
--   complexities of dates.
module Language.Drasil.Data.Date

-- | Custom type for months (abbreviated).
data Month
Jan :: Month
Feb :: Month
Mar :: Month
Apr :: Month
May :: Month
Jun :: Month
Jul :: Month
Aug :: Month
Sep :: Month
Oct :: Month
Nov :: Month
Dec :: Month
instance GHC.Classes.Ord Language.Drasil.Data.Date.Month
instance GHC.Classes.Eq Language.Drasil.Data.Date.Month
instance GHC.Show.Show Language.Drasil.Data.Date.Month


-- | A collection of |String|-handling routines as well as one for making
--   <tt>tables</tt>
module Language.Drasil.Misc

-- | Create a table body (not including header row) by applying the given
--   functions to the column elements of the table rows (in order). The
--   first argument is a list of functions to be applied (one per column).
--   This essentially creates the rows. The second argument is a list of
--   elements apply the functions to.
--   
--   For example, <tt>mkTable [id, *5] [1,2,3]</tt> should produce a table:
--   
--   <pre>
--   | 1 |  5 |
--   | 2 | 10 |
--   | 3 | 15 |
--   </pre>
mkTable :: [a -> b] -> [a] -> [[b]]

-- | Returns the given string if it doesn't contain spaces and throws an
--   error if it does.
noSpaces :: String -> String

-- | Replace underscores in a string with <a>.</a>.
repUnd :: String -> String

module Language.Drasil.People

-- | People is a synonymn for many <a>Person</a>s.
type People = [Person]

-- | A person can have a given name, middle name(s), and surname, as well
--   as the naming convention they use.
data Person

-- | Constructor for a person using Western naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   given name, surname.
person :: String -> String -> Person

-- | Constructor for a person using Eastern naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   surname, given name.
person' :: String -> String -> Person

-- | Constructor for a person using Western naming conventions. Similar to
--   the <a>person</a> constructor, except the middle argument is a list of
--   middle names.
personWM :: String -> [String] -> String -> Person

-- | Constructor for a person using Eastern naming conventions. Similar to
--   the <a>person'</a> constructor, except the middle argument is a list
--   of middle names.
personWM' :: String -> [String] -> String -> Person

-- | Constructor for a person with a mononym (only one name).
mononym :: String -> Person

-- | Members of this class must have a name.
class HasName p

-- | Gets the name of a <a>Person</a>. Adds a dot after any initials.
name :: HasName n => n -> String

-- | Provides the ability to hold a name.
nameStr :: HasName p => p -> String

-- | Naming conventions.
data Conv

-- | Western style conventions are given name followed by middle names,
--   followed by surname.
Western :: Conv

-- | Eastern style conventions are surname followed by middle names,
--   followed by given name.
Eastern :: Conv

-- | Mononyms are for those people who have only one name (ex. Madonna).
Mono :: Conv

-- | Gets the last name of a <a>Person</a>.
lstName :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, First Middle.
rendPersLFM :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, F. M.
rendPersLFM' :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, First M.
rendPersLFM'' :: Person -> String

-- | Orderes different groups of <a>Person</a>s. If two lists are the same
--   up to a point, the citation with more <a>Person</a>s will go last.
comparePeople :: [Person] -> [Person] -> Ordering
instance GHC.Classes.Eq Language.Drasil.People.Person
instance GHC.Classes.Eq Language.Drasil.People.Conv
instance Language.Drasil.People.HasName Language.Drasil.People.Person

module Language.Drasil.Data.Citation

-- | Fields used in citations.
data CiteField
Address :: String -> CiteField
Author :: People -> CiteField

-- | Used for <a>InCollection</a> references only.
BookTitle :: String -> CiteField
Chapter :: Int -> CiteField
Edition :: Int -> CiteField
Editor :: People -> CiteField

-- | Can be published via URL or something else.
HowPublished :: HP -> CiteField
Institution :: String -> CiteField
Journal :: String -> CiteField
Month :: Month -> CiteField
Note :: String -> CiteField
Number :: Int -> CiteField
Organization :: String -> CiteField

-- | Range of pages (ex1. 1-32; ex2. 7,31,52-55).
Pages :: [Int] -> CiteField
Publisher :: String -> CiteField
School :: String -> CiteField
Series :: String -> CiteField
Title :: String -> CiteField

-- | BibTeX "type" field.
Type :: String -> CiteField
Volume :: Int -> CiteField
Year :: Int -> CiteField

-- | How something is published. Necessary for URLs to work properly.
data HP
URL :: String -> HP
Verb :: String -> HP

-- | External references come in many flavours. Articles, Books, etc. (we
--   are using the types available in Bibtex).
data CitationKind
Article :: CitationKind
Book :: CitationKind
Booklet :: CitationKind
InBook :: CitationKind
InCollection :: CitationKind
InProceedings :: CitationKind
Manual :: CitationKind
MThesis :: CitationKind
Misc :: CitationKind
PhDThesis :: CitationKind
Proceedings :: CitationKind
TechReport :: CitationKind
Unpublished :: CitationKind

-- | Smart field constructor for a <a>CiteField</a>.
author :: People -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
editor :: People -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
address :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
bookTitle :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
howPublished :: String -> CiteField

-- | URL version of <a>howPublished</a>.
--   
--   Smart field constructor for a <a>CiteField</a>.
howPublishedU :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
institution :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
journal :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
note :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
organization :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
publisher :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
school :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
series :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
title :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
typeField :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
chapter :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
edition :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
number :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
volume :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
year :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
pages :: [Int] -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
month :: Month -> CiteField


-- | Defining classes that represent knowledge about Citations
module Language.Drasil.Classes.Citations

-- | <tt>Citation</tt>s should have a fields (<a>CiteField</a>).
class HasFields c

-- | Provides a <tt>Lens</tt> to <a>CiteField</a>s.
getFields :: HasFields c => Lens' c [CiteField]

module Language.Drasil.Stages

-- | Stages correspond to what we're trying to look up. They range from
--   abstract to concrete. Equational stages are more theoretical and
--   oriented towards abstract design while the Implementation stages are
--   more oriented towards detailed design.
data Stage
Equational :: Stage
Implementation :: Stage
instance GHC.Show.Show Language.Drasil.Stages.Stage

module Language.Drasil.UID

-- | A <tt>UID</tt> is a 'unique identifier' for things that we will put
--   into our database of information.
type UID = String


-- | Even though we do not have <tt>Label</tt>s per se, here we define the
--   different ways of construction ways to mark labels.
module Language.Drasil.Label.Type

-- | Applying different pieces of information for a reference. An RP is a
--   decorated internal reference. Citation is a citation. URI is for URLs
--   and other external links.
data LblType
RP :: IRefProg -> String -> LblType
Citation :: String -> LblType
URI :: String -> LblType

-- | Created for different forms of references. Used in <a>LblType</a>.
data IRefProg

-- | Deferred lookup; done later. Used for domains in a
--   <tt>ConceptInstance</tt>.
Deferred :: UID -> IRefProg

-- | Lifts a <a>String</a> into a <tt>RefProg</tt>.
RS :: String -> IRefProg

-- | Concatenates with two subprograms.
RConcat :: IRefProg -> IRefProg -> IRefProg

-- | The <tt>Symbol</tt> to insert the <tt>ShortName</tt> directly.
Name :: IRefProg

-- | Retrieves the <a>String</a> contained in a <a>LblType</a>.
getAdd :: LblType -> String

-- | Constructor that gets the <a>Name</a> of an <a>IRefProg</a>.
name :: IRefProg

-- | Constructor that concatenates two subprograms.
(+::+) :: IRefProg -> IRefProg -> IRefProg

-- | Constructor for a <a>String</a> into an <a>IRefProg</a>.
raw :: String -> IRefProg

-- | Constructor to defer a <a>UID</a> lookup; done later.
defer :: UID -> IRefProg

-- | Prepends a <a>String</a> to an <a>IRefProg</a>.
prepend :: String -> IRefProg


-- | Abstract Syntax Tree for Uniform Resource Identifiers
module Language.Drasil.URI.AST

-- | A uniform resource identifier (uses URLs or ISBNs).
data URI
URL :: Scheme -> Authority -> Path -> Query -> Fragment -> URI
ISBN :: String -> URI

-- | URL scheme (either HTTP or FTP).
data Scheme
HTTP :: Scheme
FTP :: Scheme

-- | Authentication if necessary.
data Authority

-- | Full authentication.
Full :: Username -> Password -> Host -> Port -> Authority

-- | Simplify for when authentication isn't necessary.
Simple :: Host -> Port -> Authority
type Path = String " Type the full path excluding the first /."
type Query = [String] " Make sure [] doesn't print a "?". Separate elements with "&"."
type Fragment = String " Make sure "" becomes "" not "#" when printing."
type Username = String " Again make sure "" doesn't print anything."
type Password = String " Don't print anything if "" or if Username=""."
type Host = String " Type the host address (ex. "www.github.com")."
data Port

-- | Take an integer port number if applicable.
P :: Int -> Port

-- | Do nothing if port is not applicable.
NA :: Port

module Language.Drasil.Uncertainty.Core

-- | Something that may contain an uncertainty value and a precision value.
data Uncertainty
uncert :: Lens' Uncertainty (Maybe Double)
prec :: Lens' Uncertainty (Maybe Int)

-- | Smart constructor for values with uncertainty.
uncty :: Double -> Maybe Int -> Uncertainty

-- | Smart constructor for exact values (no uncertainty).
exact :: Uncertainty

module Language.Drasil.Unicode

-- | Special characters include partial derivatives and the degree circle.
data Special
Partial :: Special
Circle :: Special

-- | Class for rendering special characters.
class RenderSpecial r
special :: RenderSpecial r => Special -> r
instance GHC.Classes.Ord Language.Drasil.Unicode.Special
instance GHC.Classes.Eq Language.Drasil.Unicode.Special

module Language.Drasil.Symbol

-- | Decorations on symbols/characters such as hats or Vector
--   representations (determines bolding, italics, etc).
data Decoration
Hat :: Decoration
Vector :: Decoration
Prime :: Decoration

-- | A <a>Symbol</a> is actually going to be a graphical description of
--   what gets rendered as a (unique) symbol. This is actually NOT based on
--   semantics at all, but just a description of how things look.
--   
--   Symbols can be:
--   
--   <ul>
--   <li><tt><a>Variable</a></tt> (string such as "x" that represent a
--   value that can vary)</li>
--   <li><tt><a>Label</a></tt> (strings such as "max" or "target" that
--   represent a single idea)</li>
--   <li><tt><a>Special</a></tt> characters (ex. unicode)</li>
--   <li><tt>Decorated</tt> symbols</li>
--   <li><tt>Concatenations</tt> of symbols, including subscripts and
--   superscripts</li>
--   <li><tt><a>Empty</a></tt>! (this is to give this a monoid-like
--   flavour)</li>
--   </ul>
data Symbol
Variable :: String -> Symbol
Label :: String -> Symbol
Integ :: Int -> Symbol
Special :: Special -> Symbol
Atop :: Decoration -> Symbol -> Symbol

-- | Order of Symbols: upleft lowleft upright lowright base
--   
--   <pre>
--   Corners [1]   [2]   [3]   [4]   [5]
--   </pre>
--   
--   <pre>
--   Visually:  [1]   [3]
--   
--                 [5]
--   
--              [2]   [4]
--   </pre>
Corners :: [Symbol] -> [Symbol] -> [Symbol] -> [Symbol] -> Symbol -> Symbol

-- | Concatentation of two symbols: <tt>[s1, s2] -&gt; s1s2</tt>
Concat :: [Symbol] -> Symbol
Empty :: Symbol

-- | The default compare function that sorts all the lower case symbols
--   after the upper case ones.
--   
--   Comparation is used twice for each <tt>Atomic</tt> case, once for
--   making sure they are the same letter, once for case sensitive. As far
--   as this comparison is considered, <tt>Δ</tt> is a "decoration" and
--   ignored unless the compared symbols are the exact same, in which case
--   it is ordered after the undecorated symbol.
--   
--   Superscripts and subscripts are ordered after the base symbols
--   (because they add additional context to a symbol). For example:
--   `v_f^{AB}` (expressed in LaTeX notation for clarity), where
--   <tt>v_f</tt> is a final velocity, and the `^{AB}` adds context that it
--   is the final velocity between points <tt>A</tt> and <tt>B</tt>. In
--   these cases, the sorting of `v_f^{AB}` should be following
--   <tt>v_f</tt> as it is logical to place it with its parent concept.
compsy :: Symbol -> Symbol -> Ordering
instance GHC.Classes.Eq Language.Drasil.Symbol.Symbol
instance GHC.Classes.Ord Language.Drasil.Symbol.Decoration
instance GHC.Classes.Eq Language.Drasil.Symbol.Decoration
instance GHC.Base.Semigroup Language.Drasil.Symbol.Symbol
instance GHC.Base.Monoid Language.Drasil.Symbol.Symbol

module Language.Drasil.Space

-- | The difference kinds of spaces that may exist. This type holds
--   numerical spaces (such as the set of integers, rationals, etc.), a
--   space for booleans, a space for characters, dimensional spaces
--   (vectors, arrays, etc.), a space for Actors, discrete sets (both for
--   numbers and strings), and a void space.
data Space
Integer :: Space
Rational :: Space
Real :: Space
Natural :: Space
Boolean :: Space
Char :: Space
String :: Space
Radians :: Space
Vect :: Space -> Space
Array :: Space -> Space
Actor :: String -> Space
DiscreteD :: [Double] -> Space
DiscreteS :: [String] -> Space
Function :: NonEmpty Primitive -> Primitive -> Space
Void :: Space

-- | Describes the domain of a <a>Symbol</a> given a topology. Can be
--   bounded or encase all of the domain.
data DomainDesc a b
[BoundedDD] :: Symbol -> RTopology -> a -> b -> DomainDesc a b
[AllDD] :: Symbol -> RTopology -> DomainDesc a b

-- | A RealInterval is a subset of <a>Real</a> (as a <a>Space</a>). These
--   come in different flavours. For now, we embed <tt>Expr</tt> for the
--   bounds, but that will change as well.
data RealInterval a b
[Bounded] :: (Inclusive, a) -> (Inclusive, b) -> RealInterval a b
[UpTo] :: (Inclusive, a) -> RealInterval a b
[UpFrom] :: (Inclusive, b) -> RealInterval a b

-- | Topology of a subset of reals.
data RTopology
Continuous :: RTopology
Discrete :: RTopology

-- | Inclusitivity of a <a>Space</a>.
data Inclusive
Inc :: Inclusive
Exc :: Inclusive

-- | Gets the name of an <a>Actor</a>.
getActorName :: Space -> String

-- | Gets the inner <a>Space</a> of a vector.
getInnerSpace :: Space -> Space
mkFunction :: [Primitive] -> Primitive -> Space
instance GHC.Show.Show Language.Drasil.Space.Space
instance GHC.Classes.Eq Language.Drasil.Space.Space


-- | The Drasil Expression language
module Language.Drasil.Expr

-- | A relation is just an expression (<a>Expr</a>).
type Relation = Expr

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product).
data VVVBinOp
Cross :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
AddI :: AssocArithOper
AddRe :: AssocArithOper
MulI :: AssocArithOper
MulRe :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | For case expressions (either complete or incomplete).
data Completeness
Complete :: Completeness
Incomplete :: Completeness

-- | Drasil expressions.
data Expr

-- | Turns a decimal value (<a>Double</a>) into an expression.
[Dbl] :: Double -> Expr

-- | Turns an integer into an expression.
[Int] :: Integer -> Expr

-- | Represents decimal values that are exact as integers.
[ExactDbl] :: Integer -> Expr

-- | Turns a string into an expression.
[Str] :: String -> Expr

-- | Turns two integers into a fraction (or percent).
[Perc] :: Integer -> Integer -> Expr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [Expr] -> Expr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [Expr] -> Expr

-- | Derivative syntax is: Type (<a>Part</a>ial or <a>Total</a>) -&gt;
--   principal part of change -&gt; with respect to For example: Deriv Part
--   y x1 would be (dy/dx1).
[Deriv] :: DerivType -> Expr -> UID -> Expr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> Expr

-- | A function call accepts a list of parameters and a list of named
--   parameters. For example
--   
--   <ul>
--   <li>F(x) is (FCall F [x] []).</li>
--   <li>F(x,y) would be (FCall F [x,y]).</li>
--   <li>F(x,n=y) would be (FCall F [x] [(n,y)]).</li>
--   </ul>
[FCall] :: UID -> [Expr] -> [(UID, Expr)] -> Expr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(Expr, Relation)] -> Expr

-- | Represents a matrix of expressions.
[Matrix] :: [[Expr]] -> Expr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> Expr -> Expr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> Expr -> Expr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> Expr -> Expr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> Expr -> Expr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> Expr -> Expr -> Expr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> Expr -> Expr -> Expr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> Expr -> Expr -> Expr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> Expr -> Expr -> Expr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> Expr -> Expr -> Expr

-- | Operators are generalized arithmetic operators over a
--   <a>DomainDesc</a> of an <a>Expr</a>. Could be called BigOp. ex:
--   Summation is represented via <tt>Add</tt> over a discrete domain.
[Operator] :: AssocArithOper -> DomainDesc Expr Expr -> Expr -> Expr

-- | A different kind of <tt>IsIn</tt>. A <a>UID</a> is an element of an
--   interval.
[RealI] :: UID -> RealInterval Expr Expr -> Expr

-- | Smart constructor for equating two expressions.
($=) :: Expr -> Expr -> Expr
infixr 4 $=

-- | Smart constructor for showing that two expressions are not equal.
($!=) :: Expr -> Expr -> Expr

-- | Less than.
--   
--   Smart constructor for ordering two equations.
($<) :: Expr -> Expr -> Expr

-- | Greater than.
--   
--   Smart constructor for ordering two equations.
($>) :: Expr -> Expr -> Expr

-- | Less than or equal to.
--   
--   Smart constructor for ordering two equations.
($<=) :: Expr -> Expr -> Expr

-- | Greater than or equal to.
--   
--   Smart constructor for ordering two equations.
($>=) :: Expr -> Expr -> Expr

-- | Smart constructor for the dot product of two equations.
($.) :: Expr -> Expr -> Expr

-- | Add two expressions (Integers).
addI :: Expr -> Expr -> Expr

-- | Add two expressions (Real numbers).
addRe :: Expr -> Expr -> Expr

-- | Multiply two expressions (Integers).
mulI :: Expr -> Expr -> Expr

-- | Multiply two expressions (Real numbers).
mulRe :: Expr -> Expr -> Expr

-- | Smart constructor for subtracting two expressions.
($-) :: Expr -> Expr -> Expr

-- | Smart constructor for dividing two expressions.
($/) :: Expr -> Expr -> Expr
infixl 7 $/

-- | Smart constructor for rasing the first expression to the power of the
--   second.
($^) :: Expr -> Expr -> Expr
infixr 8 $^

-- | Smart constructor to show that one expression implies the other
--   (conditional operator).
($=>) :: Expr -> Expr -> Expr

-- | Smart constructor to show that an expression exists if and only if
--   another expression exists (biconditional operator).
($<=>) :: Expr -> Expr -> Expr

-- | Smart constructor for the boolean <i>and</i> operator.
($&&) :: Expr -> Expr -> Expr
infixr 9 $&&

-- | Smart constructor for the boolean <i>or</i> operator.
($||) :: Expr -> Expr -> Expr
infixr 9 $||

-- | The variable type is just a renamed <a>String</a>.
type Variable = String

-- | Determines the type of the derivative (either a partial derivative or
--   a total derivative).
data DerivType
Part :: DerivType
Total :: DerivType
instance GHC.Classes.Eq Language.Drasil.Expr.DerivType
instance GHC.Classes.Eq Language.Drasil.Expr.Completeness
instance GHC.Classes.Eq Language.Drasil.Expr.UFuncVN
instance GHC.Classes.Eq Language.Drasil.Expr.UFuncVV
instance GHC.Classes.Eq Language.Drasil.Expr.UFuncB
instance GHC.Classes.Eq Language.Drasil.Expr.UFunc
instance GHC.Classes.Eq Language.Drasil.Expr.AssocBoolOper
instance GHC.Classes.Eq Language.Drasil.Expr.AssocArithOper
instance GHC.Classes.Eq Language.Drasil.Expr.VVNBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.VVVBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.OrdBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.LABinOp
instance GHC.Classes.Eq Language.Drasil.Expr.BoolBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.EqBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.ArithBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Expr

module Language.Drasil.DisplayExpr

-- | A variant of the expression language that allows for extensions of
--   Expr that wouldn't normally type check, or that we only care for
--   displaying.
data DisplayExpr
[AlgebraicExpr] :: Expr -> DisplayExpr
[SpaceExpr] :: Space -> DisplayExpr
[BinOp] :: DisplayBinOp -> DisplayExpr -> DisplayExpr -> DisplayExpr
[AssocBinOp] :: DisplayAssocBinOp -> [DisplayExpr] -> DisplayExpr

-- | Binary Display Operations.
data DisplayBinOp
Defines :: DisplayBinOp
IsIn :: DisplayBinOp

-- | Associative Binary Display Operations.
data DisplayAssocBinOp
And :: DisplayAssocBinOp
Equivalence :: DisplayAssocBinOp
instance GHC.Show.Show Language.Drasil.DisplayExpr.DisplayAssocBinOp
instance GHC.Classes.Eq Language.Drasil.DisplayExpr.DisplayAssocBinOp
instance GHC.Show.Show Language.Drasil.DisplayExpr.DisplayBinOp
instance GHC.Classes.Eq Language.Drasil.DisplayExpr.DisplayBinOp

module Language.Drasil.Expr.Precedence

-- | prec2Arith - precedence for arithmetic-related binary operations.
prec2Arith :: ArithBinOp -> Int

-- | prec2Bool - precedence for boolean-related binary operations.
prec2Bool :: BoolBinOp -> Int

-- | prec2Eq - precedence for equality-related binary operations.
prec2Eq :: EqBinOp -> Int

-- | prec2LA - precedence for access-related binary operations.
prec2LA :: LABinOp -> Int

-- | prec2Ord - precedence for order-related binary operations.
prec2Ord :: OrdBinOp -> Int

-- | prec2VVV - precedence for Vec-&gt;Vec-&gt;Vec-related binary
--   operations.
prec2VVV :: VVVBinOp -> Int

-- | prec2VVN - precedence for Vec-&gt;Vec-&gt;Num-related binary
--   operations.
prec2VVN :: VVNBinOp -> Int

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | prec1 - precedence of unary operators.
prec1 :: UFunc -> Int

-- | prec1B - precedence of boolean-related unary operators.
prec1B :: UFuncB -> Int

-- | prec1VV - precedence of vector-vector-related unary operators.
prec1VV :: UFuncVV -> Int

-- | prec1Vec - precedence of vector-number-related unary operators.
prec1VN :: UFuncVN -> Int

-- | eprec - <a>Expression</a> precedence.
eprec :: Expr -> Int

-- | dePrec - "Display Expression" precedence.
dePrec :: DisplayExpr -> Int

-- | dePrecB - precedence for binary operators.
dePrecB :: DisplayBinOp -> Int

-- | dePrecAssoc - precedence for associative binary operators.
dePrecAssoc :: DisplayAssocBinOp -> Int

module Language.Drasil.Expr.Extract

-- | Generic traverse of all display expressions that could lead to names.
deNames :: DisplayExpr -> [String]

-- | Generic traverse of all expressions that could lead to names.
eNames :: Expr -> [String]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>eNames</a>).
eNamesRI :: RealInterval Expr Expr -> [String]

-- | Generic traverse of all display expressions that could lead to names
--   (same as <a>deNames</a>).
deNames' :: DisplayExpr -> [String]

-- | Generic traverse of all positions that could lead to <a>eNames</a>
--   without functions. FIXME : this should really be done via post-facto
--   filtering, but right now the information needed to do this is not
--   available!
eNames' :: Expr -> [String]

-- | Generic traversal of everything that could come from an interval to
--   names without functions (similar to <a>eNames'</a>).
eNamesRI' :: RealInterval Expr Expr -> [String]

-- | Get dependencies from an equation.
eDep :: Expr -> [String]

-- | Get dependencies from display expressions.
deDep :: DisplayExpr -> [String]

module Language.Drasil.DisplayClasses

-- | Data that can convert into a Displayable <a>Expr</a>.
class Display c
toDispExpr :: Display c => c -> DisplayExpr
instance Language.Drasil.DisplayClasses.Display Language.Drasil.Expr.Expr
instance Language.Drasil.DisplayClasses.Display Language.Drasil.DisplayExpr.DisplayExpr

module Language.Drasil.Expr.Display

-- | One expression is "defined" by another.
defines :: (Display a, Display b) => a -> b -> DisplayExpr

-- | Bring a Space into the DisplayExpr.
spaceDE :: Space -> DisplayExpr
isIn :: Display a => a -> DisplayExpr -> DisplayExpr

-- | Binary associative <a>And</a>.
andDEs :: Display d => [d] -> DisplayExpr

-- | Binary associative <a>Equivalence</a>.
equivDEs :: Display a => [a] -> DisplayExpr

module Language.Drasil.Constraint

-- | Holds constraints. May occur between an interval of <a>Expr</a>, a
--   list of <a>Double</a>s, or a list of <a>String</a>s.
data Constraint a

-- | By default, physical and software constraints are ranges.
[Range] :: ConstraintReason -> RealInterval a a -> Constraint a

-- | Type synonym for <a>ConstraintE</a>
type ConstraintE = Constraint Expr

-- | The reason behind the constraint's existence.
data ConstraintReason
Physical :: ConstraintReason
Software :: ConstraintReason

-- | Smart constructor for range of <a>Physical</a> constraints between two
--   given expressions.
physc :: RealInterval Expr Expr -> ConstraintE

-- | Smart constructor for range of <a>Software</a> constraints between two
--   given expressions.
sfwrc :: RealInterval Expr Expr -> ConstraintE

-- | Helpful for filtering for Physical constraints. True if constraint is
--   <a>Physical</a>.
isPhysC :: Constraint e -> Bool

-- | Helpful for filtering for Software constraints. True if constraint is
--   <a>Software</a>.
isSfwrC :: Constraint e -> Bool

module Language.Drasil.Display

-- | Decorations on symbols/characters such as hats or Vector
--   representations (determines bolding, italics, etc).
data Decoration
Hat :: Decoration
Vector :: Decoration
Prime :: Decoration

-- | A <a>Symbol</a> is actually going to be a graphical description of
--   what gets rendered as a (unique) symbol. This is actually NOT based on
--   semantics at all, but just a description of how things look.
--   
--   Symbols can be:
--   
--   <ul>
--   <li><tt><a>Variable</a></tt> (string such as "x" that represent a
--   value that can vary)</li>
--   <li><tt><a>Label</a></tt> (strings such as "max" or "target" that
--   represent a single idea)</li>
--   <li><tt><a>Special</a></tt> characters (ex. unicode)</li>
--   <li><tt>Decorated</tt> symbols</li>
--   <li><tt>Concatenations</tt> of symbols, including subscripts and
--   superscripts</li>
--   <li><tt><a>Empty</a></tt>! (this is to give this a monoid-like
--   flavour)</li>
--   </ul>
data Symbol
Variable :: String -> Symbol
Label :: String -> Symbol
Integ :: Int -> Symbol
Special :: Special -> Symbol
Atop :: Decoration -> Symbol -> Symbol

-- | Order of Symbols: upleft lowleft upright lowright base
--   
--   <pre>
--   Corners [1]   [2]   [3]   [4]   [5]
--   </pre>
--   
--   <pre>
--   Visually:  [1]   [3]
--   
--                 [5]
--   
--              [2]   [4]
--   </pre>
Corners :: [Symbol] -> [Symbol] -> [Symbol] -> [Symbol] -> Symbol -> Symbol

-- | Concatentation of two symbols: <tt>[s1, s2] -&gt; s1s2</tt>
Concat :: [Symbol] -> Symbol
Empty :: Symbol

-- | The default compare function that sorts all the lower case symbols
--   after the upper case ones.
--   
--   Comparation is used twice for each <tt>Atomic</tt> case, once for
--   making sure they are the same letter, once for case sensitive. As far
--   as this comparison is considered, <tt>Δ</tt> is a "decoration" and
--   ignored unless the compared symbols are the exact same, in which case
--   it is ordered after the undecorated symbol.
--   
--   Superscripts and subscripts are ordered after the base symbols
--   (because they add additional context to a symbol). For example:
--   `v_f^{AB}` (expressed in LaTeX notation for clarity), where
--   <tt>v_f</tt> is a final velocity, and the `^{AB}` adds context that it
--   is the final velocity between points <tt>A</tt> and <tt>B</tt>. In
--   these cases, the sorting of `v_f^{AB}` should be following
--   <tt>v_f</tt> as it is logical to place it with its parent concept.
compsy :: Symbol -> Symbol -> Ordering


-- | Defining the core classes which represent knowledge-about-knowledge
module Language.Drasil.Classes.Core

-- | The most basic item: having a unique identifier key, here a UID.
class HasUID c

-- | Provides a <i>unique</i> id for internal Drasil use.
uid :: HasUID c => Lens' c UID

-- | Members must have a reference address.
class HasRefAddress b

-- | Provides the ability to hold a reference address.
getRefAdd :: HasRefAddress b => b -> LblType

-- | A HasSymbol is anything which has a <a>Symbol</a>.
class HasSymbol c

-- | Provides the <a>Symbol</a> for a particular stage of generation.
symbol :: HasSymbol c => c -> Stage -> Symbol

-- | Members of this class have the ability to be referenced.
class (HasUID s, HasRefAddress s) => Referable s

-- | The referencing address (what we're linking to). Only visible in the
--   source (tex/html).
refAdd :: Referable s => s -> String

-- | Alternate form of reference.
renderRef :: Referable s => s -> LblType


-- | Routines to help with Symbols and Stages.
module Language.Drasil.Symbol.Helpers

-- | Helper function for getting a symbol in the Equational Stage.
eqSymb :: HasSymbol q => q -> Symbol

-- | Helper function for getting a symbol in the Implementation Stage.
codeSymb :: HasSymbol q => q -> Symbol

-- | Finds if a <a>Stage</a> symbol is real or Empty. True if real.
hasStageSymbol :: HasSymbol q => q -> Stage -> Bool

-- | Helper for creating a symbol with Unicode in it.
autoStage :: Symbol -> Stage -> Symbol

-- | Helper for creating a symbol with a hat ("^") atop it.
hat :: Symbol -> Symbol

-- | Helper for creating a Vector symbol.
prime :: Symbol -> Symbol

-- | Helper for creating a symbol that depends on the stage.
staged :: Symbol -> Symbol -> Stage -> Symbol

-- | Helper for creating a symbol with a subscript to the right. Arguments:
--   Base symbol, then subscripted symbol.
sub :: Symbol -> Symbol -> Symbol

-- | Helper for a common case of subscript, with a string Arguments: Base
--   symbol, then subscript <a>String</a>.
subStr :: Symbol -> String -> Symbol

-- | Helper for creating a symbol with a superscript to the right.
--   Arguments: Base symbol, then superscripted symbol.
sup :: Symbol -> Symbol -> Symbol

-- | Helper for autoStage that applies unicodeString to all <a>Symbol</a>s
--   with <a>String</a>s.
unicodeConv :: Symbol -> Symbol

-- | Helper for creating a symbol with a superscript on the left side of
--   the symbol. Arguments: Base symbol, then superscripted symbol.
upperLeft :: Symbol -> Symbol -> Symbol

-- | Helper for creating a Vector symbol.
vec :: Symbol -> Symbol

-- | Label smart constructor, requires non-empty labels
label :: String -> Symbol

-- | Variable smart constructor, requires non-empty variables
variable :: String -> Symbol


-- | Alphabet of capital/lowercase English letters as symbols
module Language.Drasil.ShortHands

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cA :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cB :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cC :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cD :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cE :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cF :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cG :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cH :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cI :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cJ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cK :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cL :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cM :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cN :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cO :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cP :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cQ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cR :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cS :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cT :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cU :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cV :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cW :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cX :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cY :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cZ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lA :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lB :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lC :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lD :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lE :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lF :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lG :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lH :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lI :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lJ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lK :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lL :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lM :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lN :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lO :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lP :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lQ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lR :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lS :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lT :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lU :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lV :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lW :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lX :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lY :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lZ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lAlpha :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cAlpha :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lBeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cBeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lGamma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cGamma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lDelta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cDelta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lEpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
vEpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cEpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lZeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cZeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lEta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cEta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lTheta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cTheta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lIota :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cIota :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lKappa :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cKappa :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lLambda :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cLambda :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lMu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cMu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lNu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cNu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lXi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cXi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lOmicron :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cOmicron :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cPi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lRho :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cRho :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lSigma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cSigma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lTau :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cTau :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lUpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cUpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPhi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
vPhi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cPhi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lChi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cChi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPsi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cPsi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lOmega :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cOmega :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lNabla :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lEll :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPosInf :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lNegInf :: Symbol

module Language.Drasil.UnitLang

-- | Language of units (how to build them up into a unit symbol). Of the
--   form (<a>Symbol</a> ^ <a>Integer</a>). The <a>Integer</a> may be
--   negative, but should not be zero.
newtype USymb
US :: [(Symbol, Integer)] -> USymb

-- | Language of unit equations, to define a unit relative to another.
data UDefn

-- | to define straight synonyms.
USynonym :: USymb -> UDefn

-- | scale, i.e. *.
UScale :: Double -> USymb -> UDefn

-- | shift, i.e. +.
UShift :: Double -> USymb -> UDefn

-- | When we define units, they come in three flavours: SI (base) units,
--   derived SI units (aka synonyms), and defined units. The type below
--   captures that knowledge.
data UnitSymbol
BaseSI :: USymb -> UnitSymbol
DerivedSI :: USymb -> USymb -> UDefn -> UnitSymbol
Defined :: USymb -> UDefn -> UnitSymbol

-- | Generates a default unit symbol.
fromUDefn :: UDefn -> USymb

-- | Hand-rolled version of compare. Should assume <a>USymb</a> is
--   normalized, so that some redundant EQ cases can be removed.
compUSymb :: USymb -> USymb -> Ordering

-- | Generates a default unit symbol.
getUSymb :: UnitSymbol -> USymb

-- | Gets the unit definition of a unit symbol.
getDefn :: UnitSymbol -> Maybe UDefn
instance GHC.Classes.Eq Language.Drasil.UnitLang.USymb


-- | Contains Sentences and helpers
module Language.Drasil.Sentence

-- | For writing <a>Sentence</a>s via combining smaller elements.
--   <a>Sentence</a>s are made up of some known vocabulary of things:
--   
--   <ul>
--   <li>units (their visual representation)</li>
--   <li>words (via <a>String</a>s)</li>
--   <li>special characters</li>
--   <li>accented letters</li>
--   <li>references to specific layout objects</li>
--   </ul>
data Sentence

-- | Ch looks up the term for a given <a>UID</a> and displays the term with
--   a given <a>SentenceStyle</a> and <tt>CapitalizationRule</tt>. This
--   allows Sentences to hold plural forms of <tt>NounPhrase</tt>s and
--   <tt>NamedIdea</tt>s.
[Ch] :: SentenceStyle -> TermCapitalization -> UID -> Sentence

-- | A branch of Ch dedicated to SymbolStyle only.
[SyCh] :: UID -> Sentence

-- | Converts a unit symbol into a usable Sentence form.
[Sy] :: USymb -> Sentence

-- | Constructor for <a>String</a>s, used often for descriptions in Chunks.
[S] :: String -> Sentence

-- | Converts the graphical representation of a symbol into a usable
--   Sentence form.
[P] :: Symbol -> Sentence

-- | Lifts an expression into a Sentence.
[E] :: DisplayExpr -> Sentence

-- | Takes a <a>UID</a> to a reference, a display name (<a>Sentence</a>),
--   and any additional reference display information (<a>RefInfo</a>).
--   Resolves the reference later (similar to Ch).
[Ref] :: UID -> Sentence -> RefInfo -> Sentence

-- | Adds quotation marks around a Sentence.
[Quote] :: Sentence -> Sentence

-- | Used for a % symbol.
[Percent] :: Sentence

-- | Direct concatenation of two Sentences (no implicit spaces!).
[:+:] :: Sentence -> Sentence -> Sentence

-- | Empty Sentence.
[EmptyS] :: Sentence
infixr 5 :+:

-- | Used in <a>Ch</a> constructor to determine the state of a term (can
--   record whether something is in plural form, a singular term, or in
--   short form).
data SentenceStyle
PluralTerm :: SentenceStyle
TermStyle :: SentenceStyle
ShortStyle :: SentenceStyle

-- | Holds any extra information needed for a <tt>Reference</tt>, be it an
--   equation, pages, a note, or nothing.
data RefInfo
None :: RefInfo
Equation :: [Int] -> RefInfo
Page :: [Int] -> RefInfo
RefNote :: String -> RefInfo

-- | Helper for concatenating two <a>Sentence</a>s with a space between
--   them.
(+:+) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two <a>Sentence</a>s using <a>+:+</a> and
--   appends a period.
(+:+.) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two sentences using <a>+:+</a> and appends a
--   colon.
(+:) :: Sentence -> Sentence -> Sentence

-- | Helper which appends a period to the end of a <a>Sentence</a> (used
--   often as a post-fix operator).
(!.) :: Sentence -> Sentence

-- | Capitalizes a Sentence.
capSent :: Sentence -> Sentence

-- | Gets a symbol and places it in a <a>Sentence</a>.
ch :: (HasUID c, HasSymbol c) => c -> Sentence
eS :: Display d => d -> Sentence

-- | Helper for concatenating two <a>Sentence</a>s with a comma and space
--   between them.
sC :: Sentence -> Sentence -> Sentence

-- | Helper for concatenating two <a>Sentence</a>s with a space-surrounded
--   dash between them.
sDash :: Sentence -> Sentence -> Sentence

-- | Gets plural term of <a>UID</a>.
--   
--   Smart constructors for turning a <a>UID</a> into a <a>Sentence</a>.
sentencePlural :: UID -> Sentence

-- | Gets short form of <a>UID</a>.
--   
--   Smart constructors for turning a <a>UID</a> into a <a>Sentence</a>.
sentenceShort :: UID -> Sentence

-- | Gets symbol form of <a>UID</a>.
--   
--   Smart constructors for turning a <a>UID</a> into a <a>Sentence</a>.
sentenceSymb :: UID -> Sentence

-- | Gets singular form of <a>UID</a>.
--   
--   Smart constructors for turning a <a>UID</a> into a <a>Sentence</a>.
sentenceTerm :: UID -> Sentence

-- | Helper for wrapping <a>Sentence</a>s in parentheses.
sParen :: Sentence -> Sentence

-- | Used in <a>Ch</a> constructor to determine the capitalization of a
--   term. CapF is for capitalizing the first word from the <a>UID</a> of
--   the given term. CapW is for capitalizing all words from the <a>UID</a>
--   of the given term. Mirrors <tt>CapFirst</tt> and <tt>CapWords</tt>
--   from <tt>CapitalizationRule</tt>.
data TermCapitalization
CapF :: TermCapitalization
CapW :: TermCapitalization
NoCap :: TermCapitalization
instance GHC.Base.Semigroup Language.Drasil.Sentence.Sentence
instance GHC.Base.Monoid Language.Drasil.Sentence.Sentence

module Language.Drasil.ShortName

-- | Used for holding the short form of a name (as a String with a
--   wrapper).
newtype ShortName
ShortNm :: Sentence -> ShortName

-- | Pulls the short form (as a <a>String</a>) out of a <a>ShortName</a>.
getSentSN :: ShortName -> Sentence

-- | Smart constructor for making a <a>String</a> into a <a>ShortName</a>.
shortname' :: Sentence -> ShortName


-- | Defining the core classes which represent knowledge-about-knowledge
module Language.Drasil.Classes.Core2

-- | A <a>ShortName</a> is the text to be displayed for a link. Used for
--   referencing within a document that can include symbols and whatnot if
--   required. Visible in the typeset documents (pdf).
class HasShortName s
shortname :: HasShortName s => s -> ShortName

module Language.Drasil.Sentence.Extract

-- | This is to collect <i>symbolic</i> <a>UID</a>s that are printed out as
--   a <tt>Symbol</tt>.
sdep :: Sentence -> [UID]
shortdep :: Sentence -> [UID]

-- | Generic traverse of all positions that could lead to <i>reference</i>
--   <a>UID</a>s from <a>Sentence</a>s.
lnames :: Sentence -> [UID]

-- | Get <i>reference</i> <a>UID</a>s from <a>Sentence</a>s.
lnames' :: [Sentence] -> [UID]

module Language.Drasil.Reference

-- | A Reference contains the identifier (<a>UID</a>), a reference address
--   (<a>LblType</a>), a human-readable shortname (<a>ShortName</a>), and
--   any extra information about the reference (<a>RefInfo</a>).
data Reference
Reference :: UID -> LblType -> ShortName -> Reference

-- | Finds the reference information of a <a>Reference</a>.
--   
--   Projector function that creates a <a>Reference</a> from something
--   <tt>Referable</tt>.
ref :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Reference

-- | Takes the reference <a>UID</a> and wraps it into a <a>Sentence</a>.
refS :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence

-- | Takes a <a>Reference</a> with a name to be displayed and wraps it into
--   a <a>Sentence</a>. Does not overwrite the shortname contained in the
--   reference, but will only display as the given <a>Sentence</a>.
namedRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence -> Sentence

-- | Takes a <a>Reference</a> with additional display info. Uses the
--   internal shortname for its display name.
complexRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> RefInfo -> Sentence

-- | Takes a <a>Reference</a> with a name to be displayed and any
--   additional information and wraps it into a <a>Sentence</a>. Does not
--   overwrite the shortname contained in the reference, but will only
--   display as the given <a>Sentence</a> along with the given
--   <a>RefInfo</a>.
namedComplexRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence -> RefInfo -> Sentence
instance GHC.Classes.Eq Language.Drasil.Reference.Reference
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Reference.Reference
instance Language.Drasil.Classes.Core.HasRefAddress Language.Drasil.Reference.Reference
instance Language.Drasil.Classes.Core2.HasShortName Language.Drasil.Reference.Reference

module Language.Drasil.NounPhrase.Core

-- | Capitalization rules.
data CapitalizationRule

-- | Capitalize the first letter of the first word only.
CapFirst :: CapitalizationRule

-- | Capitalize the first letter of each word.
CapWords :: CapitalizationRule

-- | Replace the noun phrase with the given <a>Sentence</a>. Used for
--   custom capitalization.
Replace :: Sentence -> CapitalizationRule

-- | For nouns and <tt>NounPhrase</tt>s. May be constructed from a proper
--   noun, common noun, or phrase (<a>Sentence</a>) and their respective
--   pluralization and capitalization rules.
data NP

-- | Stores a proper noun and its pluralization.
ProperNoun :: String -> PluralRule -> NP

-- | Stores a common noun and its pluralization.
CommonNoun :: String -> PluralRule -> CapitalizationRule -> NP

-- | Stores noun phrase and its pluralization. Phrase plurals can get very
--   odd, so it seems best (for now) to encode them directly. FIXME: If the
--   singular/plural phrase has special (replace) capitalization, one of
--   the two cannot be capitalized right now. The two capitalization rules
--   are for sentenceCase / titleCase respectively
Phrase :: Sentence -> PluralForm -> CapitalizationRule -> CapitalizationRule -> NP

-- | Synonym for <a>Sentence</a> typically used for plural forms.
type PluralForm = Sentence

-- | Pluralization rules.
data PluralRule

-- | Add "s" to the end of the noun phrase.
AddS :: PluralRule

-- | Add "e" to the end of the noun phrase.
AddE :: PluralRule

-- | Add "es" to the end of the noun phrase.
AddES :: PluralRule

-- | The noun phrase is already plural.
SelfPlur :: PluralRule

-- | Apply the given function to the noun phrase to get the plural.
IrregPlur :: (String -> String) -> PluralRule

module Language.Drasil.NounPhrase
class NounPhrase n

-- | Retrieves singular form of term. Ex. "the quick brown fox".
phraseNP :: NounPhrase n => n -> Sentence

-- | Retrieves plural form of term. Ex. "the quick brown foxes".
pluralNP :: NounPhrase n => n -> PluralForm

-- | Retrieves the singular form and applies a captalization rule (usually
--   capitalizes the first word) to produce a <a>Sentence</a>. Ex. "The
--   quick brown fox".
sentenceCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization

-- | Retrieves the singular form and applies a captalization rule (usually
--   capitalizes all words) to produce a <a>Sentence</a>. Ex. "The Quick
--   Brown Fox".
titleCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization

-- | For nouns and <tt>NounPhrase</tt>s. May be constructed from a proper
--   noun, common noun, or phrase (<a>Sentence</a>) and their respective
--   pluralization and capitalization rules.
data NP

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
atStartNP :: NounPhrase n => n -> Capitalization

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
atStartNP' :: NounPhrase n => n -> Capitalization

-- | Self plural.
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn :: String -> NP

-- | Plural form simply adds "s" (ex. dog -&gt; dogs).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn' :: String -> NP

-- | Plural form adds "e" (ex. formula -&gt; formulae).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn'' :: String -> NP

-- | Plural form adds "es" (ex. bush -&gt; bushes).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn''' :: String -> NP

-- | Construct a common noun that pluralizes by dropping the last two
--   letters and adding an "ices" ending (ex. matrix -&gt; matrices).
cnICES :: String -> NP

-- | Constructs a common noun that pluralizes by dropping the last letter
--   and adding an "ies" ending (ex. body -&gt; bodies).
cnIES :: String -> NP

-- | Constructs a common noun that allows you to specify the pluralization
--   rule (as in <a>pnIrr</a>).
cnIP :: String -> PluralRule -> NP

-- | Constructs a common noun that pluralizes by dropping the last two
--   letters and adding "es" (ex. analysis -&gt; analyses).
cnIS :: String -> NP

-- | Common noun that allows you to specify both the pluralization rule and
--   the capitalization rule for sentence case (if the noun is used at the
--   beginning of a sentence).
cnIrr :: String -> PluralRule -> CapitalizationRule -> NP

-- | Constructs a common noun that pluralizes by dropping the last two
--   letters and adding "a" (ex. datum -&gt; data).
cnUM :: String -> NP

-- | Combine two noun phrases. The singular form becomes <tt>phrase</tt>
--   from t1 followed by <tt>phrase</tt> of t2. The plural becomes
--   <tt>phrase</tt> of t1 followed by <tt>plural</tt> of t2. Uses standard
--   <a>CapFirst</a> sentence case and <a>CapWords</a> title case. For
--   example: <tt>compoundPhrase system constraint</tt> will have singular
--   form "system constraint" and plural "system constraints".
compoundPhrase :: (NounPhrase a, NounPhrase b) => a -> b -> NP

-- | Similar to <a>compoundPhrase</a>, but the sentence case is the same as
--   the title case (<a>CapWords</a>).
compoundPhrase' :: NP -> NP -> NP

-- | Similar to <a>compoundPhrase'</a>, but accepts two functions that will
--   be used to construct the plural form. For example,
--   <tt>compoundPhrase'' plural phrase system constraint</tt> would have
--   the plural form "systems constraint".
compoundPhrase'' :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Similar to <a>compoundPhrase</a>, but used when you need a special
--   function applied to the first term of both singular and pluralcases
--   (eg. short or plural).
compoundPhrase''' :: (NP -> Sentence) -> NP -> NP -> NP

-- | Similar to <a>compoundPhrase</a>, but pluralizes the first <a>NP</a>
--   for both singular and plural cases.
compoundPhraseP1 :: NP -> NP -> NP

-- | Creates a <a>NP</a> with a given singular and plural form (as
--   <a>String</a>s) that capitalizes the first letter of the first word
--   for sentence case.
nounPhrase :: String -> PluralString -> NP

-- | Similar to <a>nounPhrase</a>, but takes a specified capitalization
--   rule for the sentence case.
nounPhrase' :: String -> PluralString -> CapitalizationRule -> NP

-- | Custom noun phrase constructor that takes a singular form
--   (<a>Sentence</a>), plural form (<a>Sentence</a>), sentence case
--   capitalization rule, and title case capitalization rule.
nounPhrase'' :: Sentence -> PluralForm -> CapitalizationRule -> CapitalizationRule -> NP

-- | For things that should not be pluralized (or are self-plural). Works
--   like <a>nounPhrase</a>, but with only the first argument.
nounPhraseSP :: String -> NP

-- | Similar to nounPhrase, except it only accepts one <a>Sentence</a>.
--   Used for Requirements, Assumptions, LikelyChanges, etc. to allow for
--   referencing. Plural case is just <a>AddS</a>.
nounPhraseSent :: Sentence -> NP

-- | Self plural.
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn :: String -> NP

-- | Plural form simply adds "s" (ex. Henderson -&gt; Hendersons).
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn' :: String -> NP

-- | Plural form adds "e".
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn'' :: String -> NP

-- | Plural form adds "es" (ex. Bush -&gt; Bushes).
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn''' :: String -> NP

-- | Constructs a <a>ProperNoun</a> with a custom plural rule (using
--   <a>IrregPlur</a> from <a>PluralRule</a>). First argument is the String
--   representing the noun, second is the rule.
pnIrr :: String -> PluralRule -> NP

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP :: NounPhrase n => n -> Capitalization

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP' :: NounPhrase n => n -> Capitalization

-- | Capitalization rules.
data CapitalizationRule

-- | Capitalize the first letter of the first word only.
CapFirst :: CapitalizationRule

-- | Capitalize the first letter of each word.
CapWords :: CapitalizationRule

-- | Replace the noun phrase with the given <a>Sentence</a>. Used for
--   custom capitalization.
Replace :: Sentence -> CapitalizationRule

-- | Pluralization rules.
data PluralRule

-- | Add "s" to the end of the noun phrase.
AddS :: PluralRule

-- | Add "e" to the end of the noun phrase.
AddE :: PluralRule

-- | Add "es" to the end of the noun phrase.
AddES :: PluralRule

-- | The noun phrase is already plural.
SelfPlur :: PluralRule

-- | Apply the given function to the noun phrase to get the plural.
IrregPlur :: (String -> String) -> PluralRule
instance Language.Drasil.NounPhrase.NounPhrase Language.Drasil.NounPhrase.Core.NP

module Language.Drasil.Development
class NounPhrase n

-- | Retrieves singular form of term. Ex. "the quick brown fox".
phraseNP :: NounPhrase n => n -> Sentence

-- | Retrieves plural form of term. Ex. "the quick brown foxes".
pluralNP :: NounPhrase n => n -> PluralForm

-- | A variant of the expression language that allows for extensions of
--   Expr that wouldn't normally type check, or that we only care for
--   displaying.
data DisplayExpr
[AlgebraicExpr] :: Expr -> DisplayExpr
[SpaceExpr] :: Space -> DisplayExpr
[BinOp] :: DisplayBinOp -> DisplayExpr -> DisplayExpr -> DisplayExpr
[AssocBinOp] :: DisplayAssocBinOp -> [DisplayExpr] -> DisplayExpr

-- | Binary Display Operations.
data DisplayBinOp
Defines :: DisplayBinOp
IsIn :: DisplayBinOp

-- | Associative Binary Display Operations.
data DisplayAssocBinOp
And :: DisplayAssocBinOp
Equivalence :: DisplayAssocBinOp

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product).
data VVVBinOp
Cross :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | Get dependencies from an equation.
eDep :: Expr -> [String]

-- | Generic traverse of all expressions that could lead to names.
eNames :: Expr -> [String]

-- | Generic traverse of all positions that could lead to <a>eNames</a>
--   without functions. FIXME : this should really be done via post-facto
--   filtering, but right now the information needed to do this is not
--   available!
eNames' :: Expr -> [String]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>eNames</a>).
eNamesRI :: RealInterval Expr Expr -> [String]

-- | Get dependencies from display expressions.
deDep :: DisplayExpr -> [String]

-- | This is to collect <i>symbolic</i> <a>UID</a>s that are printed out as
--   a <tt>Symbol</tt>.
sdep :: Sentence -> [UID]

-- | Generic traverse of all positions that could lead to <i>reference</i>
--   <a>UID</a>s from <a>Sentence</a>s.
lnames :: Sentence -> [UID]

-- | Get <i>reference</i> <a>UID</a>s from <a>Sentence</a>s.
lnames' :: [Sentence] -> [UID]

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | eprec - <a>Expression</a> precedence.
eprec :: Expr -> Int

-- | dePrec - "Display Expression" precedence.
dePrec :: DisplayExpr -> Int

-- | dePrecAssoc - precedence for associative binary operators.
dePrecAssoc :: DisplayAssocBinOp -> Int

module Language.Drasil.Derivation

-- | Derivations are an ordered list of sentences and expressions. They are
--   rendered in order as paragraphs and equation blocks to display the
--   derivation.
data Derivation
Derivation :: Sentence -> [Sentence] -> Derivation

-- | Smart constructor for creating a <a>Derivation</a>.
mkDeriv :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but prepends "Detailed derivation of" to
--   the header.
mkDerivName :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but without a header <a>Sentence</a>.
mkDerivNoHeader :: [Sentence] -> Derivation

module Language.Drasil.DecoratedReference

-- | For holding a <a>Reference</a> that is decorated with extra
--   information (ex. page numbers, equation sources, etc.).
data DecRef
DR :: Reference -> RefInfo -> DecRef
[_rf] :: DecRef -> Reference
[refInfo] :: DecRef -> RefInfo

-- | Same as <a>ref</a>, but for <a>DecRef</a> instead of <a>Reference</a>.
dRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> DecRef

-- | For creating a decorated reference (<a>DecRef</a>) with extra
--   reference information (<a>RefInfo</a>).
dRefInfo :: (HasUID r, HasRefAddress r, HasShortName r) => r -> RefInfo -> DecRef
instance GHC.Classes.Eq Language.Drasil.DecoratedReference.DecRef
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.DecoratedReference.DecRef
instance Language.Drasil.Classes.Core.HasRefAddress Language.Drasil.DecoratedReference.DecRef
instance Language.Drasil.Classes.Core2.HasShortName Language.Drasil.DecoratedReference.DecRef

module Language.Drasil.Chunk.Citation

-- | All citations require a unique identifier used by the Drasil chunk. We
--   will re-use the <a>UID</a> part as an EntryID (<a>String</a>) used for
--   creating reference links. Finally we will have the reference
--   information (<a>CitationKind</a>, <a>CiteField</a>s, and a
--   <a>ShortName</a>).
data Citation
type BibRef = [Citation] " A list of 'Citation's."
type EntryID = String " A 'String' that should contain no spaces."
citeID :: Lens' Citation UID
citeKind :: Lens' Citation CitationKind

-- | Article citation requires author(s), title, journal, year. Optional
--   fields can be: volume, number, pages, month, and note. Implicitly uses
--   the EntryID as the chunk id.
cArticle :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by author.
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk id.
cBookA :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by editor.
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk id.
cBookE :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Booklet citation requires title. Optional fields can be author, how
--   published, address, month, year, note. Implicitly uses the EntryID as
--   the chunk id.
cBooklet :: String -> [CiteField] -> String -> Citation

-- | InBook citation by author.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id. This smart constructor includes both chapter
--   and page numbers.
cInBookACP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InBook citation by editor.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id. This smart constructor includes both chapter
--   and page numbers.
cInBookECP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookACP</a>.
--   
--   InBook citation excluding page numbers.
cInBookAC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookECP</a>.
--   
--   InBook citation excluding page numbers.
cInBookEC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookACP</a>.
--   
--   InBook citation excluding chapter.
cInBookAP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookECP</a>.
--   
--   InBook citation excluding chapter.
cInBookEP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InCollection citation requires author, title, bookTitle, publisher,
--   year. Optional fields can be editor, volume or number, series, type,
--   chapter, pages, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id.
cInCollection :: People -> String -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | InProceedings citation requires author, title, bookTitle, year.
--   Optional fields can be editor, volume or number, series, pages,
--   address, month, organization, publisher, and note. Implicitly uses the
--   EntryID as the chunk id.
cInProceedings :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Manual (technical documentation) citation requires title. Optional
--   fields can be author, organization, address, edition, month, year, and
--   note. Implicitly uses the EntryID as the chunk id.
cManual :: String -> [CiteField] -> String -> Citation

-- | Master's Thesis citation requires author, title, school, and year.
--   Optional fields can be type, address, month, and note. Implicitly uses
--   the EntryID as the chunk id.
cMThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Misc citation requires nothing. Optional fields can be author, title,
--   howpublished, month, year, and note. Implicitly uses the EntryID as
--   the chunk id.
cMisc :: [CiteField] -> String -> Citation

-- | PhD Thesis citation requires author, title, school, and year. Optional
--   fields can be type, address, month, and note. Implicitly uses the
--   EntryID as the chunk id.
cPhDThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Proceedings citation requires title and year. Optional fields can be
--   editor, volume or number, series, address, publisher, note, month, and
--   organization. Implicitly uses the EntryID as the chunk id.
cProceedings :: String -> Int -> [CiteField] -> String -> Citation

-- | Technical Report citation requires author, title, institution, and
--   year. Optional fields can be type, number, address, month, and note.
--   Implicitly uses the EntryID as the chunk id.
cTechReport :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Unpublished citation requires author, title, and note. Optional fields
--   can be month and year. Implicitly uses the EntryID as the chunk id.
cUnpublished :: People -> String -> String -> [CiteField] -> String -> Citation
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Citation.Citation
instance Language.Drasil.Classes.Core2.HasShortName Language.Drasil.Chunk.Citation.Citation
instance Language.Drasil.Classes.Citations.HasFields Language.Drasil.Chunk.Citation.Citation
instance Language.Drasil.Classes.Core.Referable Language.Drasil.Chunk.Citation.Citation
instance Language.Drasil.Classes.Core.HasRefAddress Language.Drasil.Chunk.Citation.Citation

module Language.Drasil.Document.Core

-- | Denotes the different possible types that can be used as a list.
data ListType

-- | Bulleted list.
Bullet :: [(ItemType, Maybe String)] -> ListType

-- | Enumerated list.
Numeric :: [(ItemType, Maybe String)] -> ListType

-- | Simple list with items denoted by <tt>:</tt>. Renders as "Title: Item"
Simple :: [ListTuple] -> ListType

-- | Descriptive list, renders as "<b>Title: Item</b>" (see
--   <a>ListTuple</a>).
Desc :: [ListTuple] -> ListType

-- | Renders a list of "<tt><a>Title</a></tt> is the <tt>Item</tt>".
Definitions :: [ListTuple] -> ListType

-- | Denotes how something should behave in a list (<a>ListType</a>).
data ItemType

-- | Standard singular item.
Flat :: Sentence -> ItemType

-- | Nest a list (<a>ListType</a>) as an item.
Nested :: Header -> ListType -> ItemType

-- | MaxWidthPercent should be kept in the range 1-100. Values outside this
--   range may have unexpected results. Used for specifying max figure
--   width as <tt>pagewidth*MaxWidthPercent/100</tt>.
type MaxWidthPercent = Float
type Title = Sentence
type Author = Sentence
type Header = Sentence " Used when creating sublists."
type Depth = Int
type Width = Float
type Height = Float
type ListTuple = (Title, ItemType, Maybe String) " Formats as Title: Item. For use in lists."
type Filepath = String
type Lbl = Sentence " Label."

-- | Contents may be labelled or unlabelled.
data Contents
UlC :: UnlabelledContent -> Contents
LlC :: LabelledContent -> Contents

-- | Types of definitions (general, instance, theory, or data).
data DType
General :: DType
Instance :: DType
Theory :: DType
Data :: DType

-- | Types of layout objects we deal with explicitly.
data RawContent

-- | table has: header-row, data(rows), label/caption, and a bool that
--   determines whether or not to show label.
Table :: [Sentence] -> [[Sentence]] -> Title -> Bool -> RawContent

-- | Paragraphs are just sentences.
Paragraph :: Sentence -> RawContent

-- | Block of Equations holds an expression.
EqnBlock :: DisplayExpr -> RawContent

-- | Grants the ability to label a group of <a>RawContent</a>.
DerivBlock :: Sentence -> [RawContent] -> RawContent

-- | For enumerated lists.
Enumeration :: ListType -> RawContent

-- | Defines something with a type, identifier, and <a>Contents</a>.
Defini :: DType -> [(Identifier, [Contents])] -> RawContent

-- | For creating figures in a document. Should use relative file path.
Figure :: Lbl -> Filepath -> MaxWidthPercent -> RawContent

-- | Grants the ability to reference something.
Bib :: BibRef -> RawContent

-- | Contain a graph with coordinates (<a>Sentence</a>s), maybe a width and
--   height, and a label (<a>Sentence</a>). TODO: Fill this one in.
Graph :: [(Sentence, Sentence)] -> Maybe Width -> Maybe Height -> Lbl -> RawContent

-- | An identifier is just a <a>String</a>.
type Identifier = String

-- | Contains a <a>Reference</a> and <a>RawContent</a>.
data LabelledContent
LblC :: Reference -> RawContent -> LabelledContent
[_ref] :: LabelledContent -> Reference
[_ctype] :: LabelledContent -> RawContent

-- | Only contains <a>RawContent</a>.
newtype UnlabelledContent
UnlblC :: RawContent -> UnlabelledContent
[_cntnts] :: UnlabelledContent -> RawContent
ref :: Lens' LabelledContent Reference
ctype :: Lens' LabelledContent RawContent
cntnts :: Iso' UnlabelledContent RawContent

-- | Members of this class must have <a>RawContent</a>.
class HasContents c

-- | Provides a <tt>Lens</tt> to the <a>RawContent</a>.
accessContents :: HasContents c => Lens' c RawContent

-- | Helper to prepend labels to <a>LabelledContent</a> when referencing.
prependLabel :: RawContent -> IRefProg
instance Language.Drasil.Document.Core.HasContents Language.Drasil.Document.Core.LabelledContent
instance Language.Drasil.Document.Core.HasContents Language.Drasil.Document.Core.UnlabelledContent
instance Language.Drasil.Document.Core.HasContents Language.Drasil.Document.Core.Contents
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Document.Core.LabelledContent
instance Language.Drasil.Classes.Core.HasRefAddress Language.Drasil.Document.Core.LabelledContent
instance Language.Drasil.Classes.Core2.HasShortName Language.Drasil.Document.Core.LabelledContent
instance Language.Drasil.Classes.Core.Referable Language.Drasil.Document.Core.LabelledContent


-- | Document Description Language
module Language.Drasil.Document

-- | Section Contents are split into subsections or contents, where
--   contents are standard layout objects (see <a>Contents</a>).
data SecCons
Sub :: Section -> SecCons
Con :: Contents -> SecCons
data Partition
Sections :: Partition
Part :: Partition
Chapter :: Partition

-- | Sections have a title (<a>Sentence</a>), a list of contents
--   (<a>SecCons</a>) and a shortname (<a>Reference</a>).
data Section
Section :: Title -> [SecCons] -> Reference -> Section
[tle] :: Section -> Title
[cons] :: Section -> [SecCons]
[_lab] :: Section -> Reference
lab :: Lens' Section Reference

-- | A Document has a Title (<a>Sentence</a>), Author(s) (<a>Sentence</a>),
--   and <a>Section</a>s which hold the contents of the document.
data Document
Document :: Title -> Author -> ShowTableOfContents -> [Section] -> Document

-- | Determines whether or not the table of contents appears on the
--   generated artifacts.
data ShowTableOfContents
ToC :: ShowTableOfContents
NoToC :: ShowTableOfContents

-- | Manually removes the first section of a document (table of contents
--   section).
checkToC :: Document -> Document

-- | Smart constructor for labelled content chunks.
llcc :: Reference -> RawContent -> LabelledContent

-- | Smart constructor for unlabelled content chunks (no <a>Reference</a>).
ulcc :: RawContent -> UnlabelledContent

-- | Smart constructor that wraps <a>UnlabelledContent</a> into
--   <a>Contents</a>.
mkParagraph :: Sentence -> Contents

-- | Smart constructor that wraps <a>LabelledContent</a> into
--   <a>Contents</a>.
mkFig :: Reference -> RawContent -> Contents

-- | Smart constructor similar to <a>llcc</a>, but takes in
--   <a>RawContent</a> first.
mkRawLC :: RawContent -> Reference -> LabelledContent

-- | Smart constructor for creating <a>Section</a>s with a title
--   (<a>Sentence</a>), introductory contents (ie. paragraphs, tables,
--   etc.), a list of subsections, and a shortname (<a>Reference</a>).
section :: Sentence -> [Contents] -> [Section] -> Reference -> Section

-- | Smart constructor for retrieving the contents (<a>Section</a>s) from a
--   <a>Document</a>.
extractSection :: Document -> [Section]

-- | Smart constructor for retrieving the subsections (<a>Section</a>s)
--   within a <a>Section</a>.
getSec :: Section -> [Section]

-- | Helper to retrieve subsections (<a>Section</a>s) from section contents
--   (<a>SecCons</a>).
getSecCons :: SecCons -> [Section]

-- | <a>Figure</a> smart constructor with a <a>Lbl</a> and a
--   <a>Filepath</a>. Assumes 100% of page width as max width.
fig :: Lbl -> Filepath -> RawContent

-- | <a>Figure</a> smart constructor that allows for customized max widths.
figWithWidth :: Lbl -> Filepath -> MaxWidthPercent -> RawContent

-- | Create a reference for a table. Takes in the name of a table (which
--   will also be used for its shortname).
makeTabRef :: String -> Reference

-- | Create a reference for a figure. Takes in the name of a figure (which
--   will also be used for its shortname).
makeFigRef :: String -> Reference

-- | Create a reference for a section. Takes in the name of a section and a
--   shortname for the section.
makeSecRef :: String -> Sentence -> Reference

-- | Create a reference for a <a>URI</a>.
makeURI :: UID -> String -> ShortName -> Reference
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Document.Section
instance Language.Drasil.Classes.Core2.HasShortName Language.Drasil.Document.Section
instance Language.Drasil.Classes.Core.Referable Language.Drasil.Document.Section
instance Language.Drasil.Classes.Core.HasRefAddress Language.Drasil.Document.Section


-- | Defining classes that represent knowledge about Documents
module Language.Drasil.Classes.Document

-- | Some documents, as well as some pieces of knowledge, have citations.
class HasCitation c

-- | Provides a <tt>Lens</tt> to the citations.
getCitations :: HasCitation c => Lens' c [Citation]


-- | Defining all the classes which represent knowledge-about-knowledge
module Language.Drasil.Classes

-- | A NamedIdea is a <a>term</a> that we've identified (has a <a>UID</a>)
--   as being worthy of naming.
class HasUID c => NamedIdea c

-- | Lens to the term (a noun phrase).
term :: NamedIdea c => Lens' c NP

-- | HasSpace is anything which has a <a>Space</a>.
class HasSpace c

-- | Provides a <tt>Lens</tt> to the <a>Space</a>.
typ :: HasSpace c => Lens' c Space

-- | Some chunks store a unit symbol.
class HasUnitSymbol u

-- | Provides the ability to hold a unit symbol (<a>USymb</a>).
usymb :: HasUnitSymbol u => u -> USymb

-- | A class that contains a list of <a>Reference</a>s.
class HasReference c

-- | Provides a <tt>Lens</tt> to the <a>Reference</a>s.
getReferences :: HasReference c => Lens' c [Reference]

-- | A class that contains a list of decorated references (<a>DecRef</a>s).
class HasDecRef c

-- | Provides a <tt>Lens</tt> to the <a>DecRef</a>s.
getDecRefs :: HasDecRef c => Lens' c [DecRef]

-- | A <a>Quantity</a> that could have a reasonable value.
class HasReasVal c

-- | Provides a <tt>Lens</tt> to the possible reasonable value.
reasVal :: HasReasVal c => Lens' c (Maybe Expr)

-- | A class that might have a <a>Derivation</a>.
class HasDerivation c

-- | Provides a <tt>Lens</tt> to a possible derivation.
derivations :: HasDerivation c => Lens' c (Maybe Derivation)

-- | Records any additional notes needed to avoid losing information
class HasAdditionalNotes c

-- | Provides a <tt>Lens</tt> to the notes.
getNotes :: HasAdditionalNotes c => Lens' c [Sentence]

-- | An <a>Idea</a> is the combination of a <a>NamedIdea</a> and a
--   <a>CommonIdea</a>. In other words, it <i>may</i> have an
--   acronym/abbreviation.
class NamedIdea c => Idea c

-- | Gets the acronym/abbreviation.
getA :: Idea c => c -> Maybe String

-- | Defines a chunk.
class Definition c

-- | Provides (a <tt>Lens</tt> to) the definition for a chunk.
defn :: Definition c => Lens' c Sentence

-- | Some concepts have a domain (related information encoded in
--   <a>UID</a>s to other chunks).
class ConceptDomain c

-- | Provides Getter for the concept domain tags for a chunk
--   
--   <i>cdom</i> should be exported for use by the Drasil framework, but
--   should not be exported beyond that.
cdom :: ConceptDomain c => c -> [UID]

-- | The Constrained class is a <a>Quantity</a> that has value constraints.
--   It does not enforce <a>Quantity</a> at this point.
class Constrained c

-- | Provides a <tt>Lens</tt> to the <tt>Constraint</tt>s.
constraints :: Constrained c => Lens' c [ConstraintE]

-- | CommonIdea is a <a>NamedIdea</a> with the additional constraint that
--   it <b>must</b> have an abbreviation.
class NamedIdea c => CommonIdea c

-- | Introduces abrv which necessarily provides an abbreviation.
abrv :: CommonIdea c => c -> String

-- | A better version of <tt>ExprRelat</tt> that holds an <a>Expr</a>.
class DefiningExpr c

-- | Provides a <tt>Lens</tt> to the expression.
defnExpr :: DefiningExpr c => Lens' c Expr

-- | Data that can convert into a Displayable <a>Expr</a>.
class Display c
toDispExpr :: Display c => c -> DisplayExpr

-- | A Quantity is an <a>Idea</a> with a <a>Space</a> and a
--   <tt>Symbol</tt>. In theory, it should also restrict to being a part of
--   <tt>MayHaveUnit</tt>, but that causes all sorts of import cycles (or
--   lots of orphans).
class (Idea c, HasSpace c, HasSymbol c) => Quantity c

-- | HasUncertainty is just a chunk with some uncertainty associated to it.
--   This uncertainty is represented as a decimal value between 0 and 1
--   (percentage).
class HasUncertainty c

-- | Provides the <tt>Lens</tt> to an <a>Uncertainty</a>.
unc :: HasUncertainty c => Lens' c Uncertainty

-- | Concepts are <a>Idea</a>s with definitions and domains.
type Concept c = (Idea c, Definition c, ConceptDomain c)

-- | Some chunks can be called like functions.
class (HasSymbol c) => Callable c

-- | Members must have a named argument.
class (HasSymbol c) => IsArgumentName c

-- | Units are <a>Idea</a>s with a <a>Definition</a> which store a unit
--   symbol. They must also be explicitly declared to be instances of
--   IsUnit.
class (Idea u, Definition u, HasUnitSymbol u) => IsUnit u

-- | May have a unit definition.
udefn :: IsUnit u => u -> Maybe UDefn

-- | Holds units as a list of <a>UID</a>.
getUnits :: IsUnit u => u -> [UID]

-- | Contains a <a>UDefn</a>
class UnitEq u

-- | Provides the <tt>Lens</tt> to a unit definition.
uniteq :: UnitEq u => Lens' u UDefn

module Language.Drasil.Uncertainty

-- | The default uncertainty is set to 0.1.
defaultUncrt :: Uncertainty

-- | Smart constructor for values with uncertainty.
uncty :: Double -> Maybe Int -> Uncertainty

-- | Accessor for uncertainty value from something that has an uncertainty.
uncVal :: HasUncertainty x => x -> Double

-- | Accessor for precision value from something that has an uncertainty.
uncPrec :: HasUncertainty x => x -> Maybe Int

-- | Smart constructor for exact values (no uncertainty).
exact :: Uncertainty

module Language.Drasil.Expr.Math

-- | Smart constructor for taking the absolute value of an expression.
abs_ :: Expr -> Expr

-- | Smart constructor for negating an expression.
neg :: Expr -> Expr

-- | Smart constructor to take the log of an expression.
log :: Expr -> Expr

-- | Smart constructor to take the ln of an expression.
ln :: Expr -> Expr

-- | Smart constructor to take the square root of an expression.
sqrt :: Expr -> Expr

-- | Smart constructor to apply sin to an expression.
sin :: Expr -> Expr

-- | Smart constructor to apply cos to an expression.
cos :: Expr -> Expr

-- | Smart constructor to apply tan to an expression.
tan :: Expr -> Expr

-- | Smart constructor to apply sec to an expression.
sec :: Expr -> Expr

-- | Smart constructor to apply csc to an expression.
csc :: Expr -> Expr

-- | Smart constructor to apply cot to an expression.
cot :: Expr -> Expr

-- | Smart constructor to apply arcsin to an expression.
arcsin :: Expr -> Expr

-- | Smart constructor to apply arccos to an expression.
arccos :: Expr -> Expr

-- | Smart constructor to apply arctan to an expression.
arctan :: Expr -> Expr

-- | Smart constructor for the exponential (base e) function.
exp :: Expr -> Expr

-- | Smart constructor for calculating the dimension of a vector.
dim :: Expr -> Expr

-- | Smart constructor for calculating the normal form of a vector.
norm :: Expr -> Expr

-- | Smart constructor for negating vectors.
negVec :: Expr -> Expr

-- | Smart constructor for applying logical negation to an expression.
not_ :: Expr -> Expr

-- | Smart constructor for indexing.
idx :: Expr -> Expr -> Expr

-- | Smart constructor for integers.
int :: Integer -> Expr

-- | Smart constructor for doubles.
dbl :: Double -> Expr

-- | Smart constructor for exact doubles.
exactDbl :: Integer -> Expr

-- | Smart constructor for fractions.
frac :: Integer -> Integer -> Expr

-- | Smart constructor for rational expressions (only in 1/x form).
recip_ :: Expr -> Expr

-- | Smart constructor for strings.
str :: String -> Expr

-- | Smart constructors for percents.
perc :: Integer -> Integer -> Expr

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defint :: Symbol -> Expr -> Expr -> Expr -> Expr

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defsum :: Symbol -> Expr -> Expr -> Expr -> Expr

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defprod :: Symbol -> Expr -> Expr -> Expr -> Expr

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
intAll :: Symbol -> Expr -> Expr

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
sumAll :: Symbol -> Expr -> Expr

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
prodAll :: Symbol -> Expr -> Expr

-- | Smart constructor for 'real interval' membership.
realInterval :: HasUID c => c -> RealInterval Expr Expr -> Expr

-- | Euclidean function : takes a vector and returns the sqrt of the
--   sum-of-squares.
euclidean :: [Expr] -> Expr

-- | Used by <a>euclidean</a> function (in place of <a>sum</a>) to fix
--   representation of computation.
sum' :: (Num a, Foldable t) => t a -> a

-- | Smart constructor to cross product two expressions.
cross :: Expr -> Expr -> Expr

-- | Smart constructor for case statement with complete set of cases.
completeCase :: [(Expr, Relation)] -> Expr

-- | Smart constructor for case statement with incomplete set of cases.
incompleteCase :: [(Expr, Relation)] -> Expr

-- | Smart constructor to square a function.
square :: Expr -> Expr

-- | Smart constructor to half a function exactly.
half :: Expr -> Expr

-- | Constructs 1/2.
oneHalf :: Expr

-- | Constructs 1/3.
oneThird :: Expr

-- | Matrix helper function.
m2x2 :: Expr -> Expr -> Expr -> Expr -> Expr

-- | Matrix helper function.
vec2D :: Expr -> Expr -> Expr

-- | Matrix helper function.
dgnl2x2 :: Expr -> Expr -> Expr

-- | Applies a given function with a list of parameters.
apply :: (HasUID f, HasSymbol f) => f -> [Expr] -> Expr

-- | Similar to <a>apply</a>, but converts second argument into
--   <a>Symbol</a>s.
apply1 :: (HasUID f, HasSymbol f, HasUID a, HasSymbol a) => f -> a -> Expr

-- | Similar to <a>apply</a>, but the applied function takes two parameters
--   (which are both <a>Symbol</a>s).
apply2 :: (HasUID f, HasSymbol f, HasUID a, HasSymbol a, HasUID b, HasSymbol b) => f -> a -> b -> Expr

-- | Similar to <a>apply</a>, but takes a relation to apply to
--   <a>FCall</a>.
applyWithNamedArgs :: (HasUID f, HasSymbol f, HasUID a, IsArgumentName a) => f -> [Expr] -> [(a, Expr)] -> Expr

-- | Get an <a>Expr</a> from a <a>Symbol</a>.
sy :: (HasUID c, HasSymbol c) => c -> Expr

-- | Gets the derivative of an <a>Expr</a> with respect to a <a>Symbol</a>.
deriv :: (HasUID c, HasSymbol c) => Expr -> c -> Expr

-- | Gets the derivative of an <a>Expr</a> with respect to a <a>Symbol</a>.
pderiv :: (HasUID c, HasSymbol c) => Expr -> c -> Expr

module Language.Drasil.Development.Sentence

-- | Get short form (if it exists), else get term of an <a>Idea</a>.
short :: (Idea c, HasUID c) => c -> Sentence

-- | Helper for common pattern of introducing the title-case version of a
--   noun phrase (from an Idea) followed by its abbreviation in
--   parentheses.
introduceAbb :: Idea n => n -> Sentence

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   <a>NamedIdea</a>.
atStart :: NamedIdea n => n -> Sentence

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   <a>NamedIdea</a>.
atStart' :: NamedIdea n => n -> Sentence

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   <a>NamedIdea</a>.
titleize :: NamedIdea n => n -> Sentence

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   <a>NamedIdea</a>.
titleize' :: NamedIdea n => n -> Sentence

-- | Helper for getting the phrase from a <a>NamedIdea</a> using it's UID.
phrase :: (HasUID n, NamedIdea n) => n -> Sentence

-- | Helper for getting the plural of a phrase from a <a>NamedIdea</a>.
plural :: (HasUID n, NamedIdea n) => n -> Sentence

-- | Singular possesive function
--   
--   Helper for getting the possesive cases from the term of a
--   <a>NamedIdea</a>.
phrasePoss :: NamedIdea n => n -> Sentence

-- | Plural possesive function
--   
--   Helper for getting the possesive cases from the term of a
--   <a>NamedIdea</a>.
pluralPoss :: NamedIdea n => n -> Sentence

module Language.Drasil.Chunk.NamedIdea

-- | Note that a <a>NamedChunk</a> does not have an acronym/abbreviation as
--   that's a <tt>CommonIdea</tt>, which has its own representation.
--   Contains a <a>UID</a> and a term (<a>NP</a>).
data NamedChunk

-- | <a>NamedChunk</a> constructor, takes a <a>UID</a> and a term.
nc :: String -> NP -> NamedChunk

-- | <a>IdeaDict</a> is the canonical dictionary associated to <a>Idea</a>.
--   Contains a <a>NamedChunk</a> and maybe an abbreviation
--   (<a>String</a>). Don't export the record accessors.
data IdeaDict

-- | Historical name: nw comes from 'named wrapped' from when
--   <a>NamedIdea</a> exported <a>getA</a> (now in <a>Idea</a>). But there
--   are no more wrappers, instead we have explicit dictionaries. Unwraps
--   an <a>Idea</a> and places its <a>UID</a> and <a>NP</a> into an
--   <a>IdeaDict</a> with <a>Nothing</a> for an abbreviation.
nw :: Idea c => c -> IdeaDict

-- | <a>IdeaDict</a> constructor, takes a <a>UID</a>, <a>NP</a>, and an
--   abbreviation in the form of <a>Maybe</a> <a>String</a>
mkIdea :: String -> NP -> Maybe String -> IdeaDict
instance GHC.Classes.Eq Language.Drasil.Chunk.NamedIdea.IdeaDict
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.NamedIdea.IdeaDict
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.NamedIdea.IdeaDict
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.NamedIdea.IdeaDict
instance GHC.Classes.Eq Language.Drasil.Chunk.NamedIdea.NamedChunk
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.NamedIdea.NamedChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.NamedIdea.NamedChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.NamedIdea.NamedChunk

module Language.Drasil.Chunk.CommonIdea

-- | The common idea (with <tt>NounPhrase</tt>) data type. It must have a
--   <a>UID</a>, <tt>NounPhrase</tt> for its term, an abbreviation
--   (<a>String</a>), and a domain ([<a>UID</a>]).
data CI

-- | The commonIdea smart constructor requires a chunk id (<a>UID</a>), a
--   term (<a>NP</a>), an abbreviation (<a>String</a>), and a domain
--   ([<a>UID</a>]).
commonIdea :: String -> NP -> String -> [UID] -> CI

-- | Get abbreviation in <a>Sentence</a> form from a <a>CI</a>.
getAcc :: CI -> Sentence

-- | Get abbreviation in <a>String</a> form from a <a>CI</a>.
getAccStr :: CI -> String

-- | Similar to <a>commonIdea</a>, but takes a list of <a>IdeaDict</a>
--   (often a domain).
commonIdeaWithDict :: String -> NP -> String -> [IdeaDict] -> CI

-- | Prepends the abbreviation from a <a>CommonIdea</a> to a <a>String</a>.
prependAbrv :: CommonIdea c => c -> String -> String
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.CommonIdea.CI
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.CommonIdea.CI
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.CommonIdea.CI
instance Language.Drasil.Classes.CommonIdea Language.Drasil.Chunk.CommonIdea.CI
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.CommonIdea.CI

module Language.Drasil.Chunk.Concept.Core

-- | The ConceptChunk datatype is a Concept that contains an idea
--   (<a>IdeaDict</a>), a definition (<a>Sentence</a>), and a domain
--   ([<a>UID</a>]).
data ConceptChunk
ConDict :: IdeaDict -> Sentence -> [UID] -> ConceptChunk

-- | Contains a common idea (<a>CI</a>) with a definition
--   (<a>Sentence</a>).
data CommonConcept
ComConDict :: CI -> Sentence -> CommonConcept

-- | Contains a <a>ConceptChunk</a>, reference address, and a
--   <a>ShortName</a>.
data ConceptInstance
ConInst :: ConceptChunk -> String -> ShortName -> ConceptInstance

-- | Check if something has one domain. Throws an error if there is more
--   than one.
sDom :: [UID] -> UID
instance GHC.Classes.Eq Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.Core2.HasShortName Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.Core.HasRefAddress Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.Core.Referable Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance GHC.Classes.Eq Language.Drasil.Chunk.Concept.Core.CommonConcept
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Concept.Core.CommonConcept
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Concept.Core.CommonConcept
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Concept.Core.CommonConcept
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Concept.Core.CommonConcept
instance Language.Drasil.Classes.CommonIdea Language.Drasil.Chunk.Concept.Core.CommonConcept
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Concept.Core.CommonConcept
instance GHC.Classes.Eq Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Concept.Core.ConceptChunk

module Language.Drasil.Chunk.Concept

-- | The ConceptChunk datatype is a Concept that contains an idea
--   (<a>IdeaDict</a>), a definition (<a>Sentence</a>), and a domain
--   ([<a>UID</a>]).
data ConceptChunk

-- | Smart constructor for creating concept chunks given a <tt>UID</tt>,
--   <tt>NounPhrase</tt> (<a>NP</a>) and definition (as a <a>String</a>).
--   
--   Concept domain tagging is not yet implemented in this constructor.
dcc :: String -> NP -> String -> ConceptChunk

-- | Identical to <a>dcc</a>, but takes an abbreviation (<a>String</a>).
dcc' :: String -> NP -> String -> String -> CommonConcept

-- | Similar to <a>dcc</a>, except the definition takes a <a>Sentence</a>.
dccWDS :: String -> NP -> Sentence -> ConceptChunk

-- | Similar to <a>dcc</a>, except the definition is a <a>Sentence</a> and
--   takes an abbreviation (<a>String</a>).
dccWDS' :: String -> NP -> Sentence -> String -> CommonConcept

-- | Constructor for <a>ConceptChunk</a>. Takes the definition of the
--   <a>ConceptChunk</a> as a <a>String</a>. Does not allow concept domain
--   tagging.
cc :: Idea c => c -> String -> ConceptChunk

-- | Same as <a>cc</a>, except definition is a <a>Sentence</a>.
cc' :: Idea c => c -> Sentence -> ConceptChunk

-- | Similar to <a>cc'</a>, but allows explicit tagging.
ccs :: (Idea c, Concept d) => c -> Sentence -> [d] -> ConceptChunk

-- | Constructor for a <a>ConceptInstance</a>. Takes in the Reference
--   Address (<a>String</a>), a definition (<a>Sentence</a>), a short name
--   (<a>String</a>), and a domain (or explicit tagging).
cic :: Concept c => String -> Sentence -> String -> c -> ConceptInstance

-- | For projecting out to the <a>ConceptChunk</a> data-type.
cw :: Concept c => c -> ConceptChunk

-- | Contains a common idea (<a>CI</a>) with a definition
--   (<a>Sentence</a>).
data CommonConcept

-- | Contains a <a>ConceptChunk</a>, reference address, and a
--   <a>ShortName</a>.
data ConceptInstance

module Language.Drasil.Chunk.Relation

-- | For a <a>ConceptChunk</a> that also has a <a>Relation</a> attached.
data RelationConcept

-- | Create a <a>RelationConcept</a> from a given <a>UID</a>, term
--   (<a>NP</a>), definition (<a>Sentence</a>), and <a>Relation</a>.
makeRC :: UID -> NP -> Sentence -> Relation -> RelationConcept

-- | Create a new <a>RelationConcept</a> from an old <a>Concept</a>. Takes
--   a <a>Concept</a>, new <a>UID</a> and relation.
addRelToCC :: Concept c => c -> UID -> Relation -> RelationConcept
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Relation.RelationConcept
instance GHC.Classes.Eq Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.DisplayClasses.Display Language.Drasil.Chunk.Relation.RelationConcept

module Language.Drasil.Chunk.UnitDefn

-- | For defining units. It has a <a>ConceptChunk</a> (that defines what
--   kind of unit it is), a unit symbol, maybe another (when it is a
--   synonym), perhaps a definition, and a list of <a>UID</a> of the units
--   that make up the definition.
data UnitDefn
UD :: ConceptChunk -> UnitSymbol -> [UID] -> UnitDefn
[_vc] :: UnitDefn -> ConceptChunk
[_cas] :: UnitDefn -> UnitSymbol
[_cu] :: UnitDefn -> [UID]

-- | Generates a default unit symbol.
fromUDefn :: UDefn -> USymb

-- | Helper for fundamental unit concept chunk creation. Uses the same
--   <a>String</a> for the identifier, term, and definition.
unitCon :: String -> ConceptChunk

-- | Create a derived unit chunk from a concept and a unit equation.
makeDerU :: ConceptChunk -> UnitEquation -> UnitDefn

-- | Combinator for raising a unit to a power.
(^:) :: UnitDefn -> Integer -> UnitEquation

-- | Combinator for dividing one unit by another.
(/:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying two units together.
(*:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying a unit and a symbol.
(*$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for dividing a unit and a symbol.
(/$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for mulitiplying two unit equations.
(^$) :: UnitEquation -> UnitEquation -> UnitEquation

-- | Smart constructor for new derived units from existing units.
newUnit :: String -> UnitEquation -> UnitDefn

-- | Combinator for scaling one unit by some number.
scale :: IsUnit s => Double -> s -> UDefn

-- | Combinator for shifting one unit by some number.
shift :: IsUnit s => Double -> s -> UDefn

-- | Uses self-plural term.
--   
--   Create a derived unit chunk from a <a>UID</a>, term (<a>String</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Uses term that pluralizes by adding "s" to the end.
--   
--   Create a derived unit chunk from a <a>UID</a>, term (<a>String</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC' :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Create a derived unit chunk from a <a>UID</a>, term (<a>NP</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC'' :: String -> NP -> String -> Symbol -> UDefn -> UnitDefn

-- | Smart constructor for a "fundamental" unit.
fund :: String -> String -> String -> UnitDefn

-- | Variant of the <a>fund</a>, useful for degree.
fund' :: String -> String -> Symbol -> UnitDefn

-- | We don't want an Ord on units, but this still allows us to compare
--   them.
compUnitDefn :: UnitDefn -> UnitDefn -> Ordering

-- | Create a <tt>SI_Unit</tt> with two <a>Symbol</a> representations. The
--   created <a>NP</a> is self-plural.
derCUC :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Similar to <a>derCUC</a>, but the created <a>NP</a> has the
--   <tt>AddS</tt> plural rule.
derCUC' :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Create a derived unit chunk from a <a>UID</a>, term (<a>NP</a>),
--   definition, <a>Symbol</a>, and unit equation.
derCUC'' :: String -> NP -> String -> Symbol -> UnitEquation -> UnitDefn

-- | For allowing lists to mix the two, thus forgetting the definition
--   part.
unitWrapper :: IsUnit u => u -> UnitDefn

-- | Get a list of <a>UID</a> of the units that make up the
--   <a>UnitEquation</a>.
getCu :: UnitEquation -> [UID]

-- | Types may contain a unit (<a>UnitDefn</a>).
class MayHaveUnit u
getUnit :: MayHaveUnit u => u -> Maybe UnitDefn

-- | Units are <a>Idea</a>s with a <a>Definition</a> which store a unit
--   symbol. They must also be explicitly declared to be instances of
--   IsUnit.
class (Idea u, Definition u, HasUnitSymbol u) => IsUnit u

-- | Holds units as a list of <a>UID</a>.
getUnits :: IsUnit u => u -> [UID]
instance Language.Drasil.Classes.HasUnitSymbol Language.Drasil.Chunk.UnitDefn.UnitEquation
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.UnitDefn.UnitDefn
instance GHC.Classes.Eq Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.HasUnitSymbol Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.IsUnit Language.Drasil.Chunk.UnitDefn.UnitDefn

module Language.Drasil.Chunk.Quantity

-- | QuantityDict is a combination of an <a>IdeaDict</a> with a quantity.
--   Contains an <a>IdeaDict</a>, <a>Space</a>, a function from
--   <a>Stage</a> -&gt; <a>Symbol</a>, and <a>Maybe</a> a <a>UnitDefn</a>.
data QuantityDict

-- | Makes a <a>QuantityDict</a> from an <a>Idea</a>, <a>Symbol</a>, and
--   <a>Space</a>. <a>Symbol</a> is implementation-only.
codeVC :: Idea c => c -> Symbol -> Space -> QuantityDict

-- | Makes a variable that is implementation-only.
implVar :: String -> NP -> Space -> Symbol -> QuantityDict

-- | Similar to <a>implVar</a> but allows specification of abbreviation and
--   unit.
implVar' :: String -> NP -> Maybe String -> Space -> Symbol -> Maybe UnitDefn -> QuantityDict

-- | Make a <a>QuantityDict</a> from a <tt>UID</tt>, <a>NP</a>,
--   <a>Symbol</a>, <a>Space</a>, <a>Maybe</a> <a>UnitDefn</a>, and an
--   abbreviation (<a>Maybe</a> <a>String</a>).
mkQuant :: String -> NP -> Symbol -> Space -> Maybe UnitDefn -> Maybe String -> QuantityDict

-- | Similar to <a>mkQuant</a>, but the abbreviation is moved to the third
--   argument (<a>Maybe</a> <a>String</a>), and the <a>Symbol</a> is now
--   dependent on <a>Stage</a>.
mkQuant' :: String -> NP -> Maybe String -> Space -> (Stage -> Symbol) -> Maybe UnitDefn -> QuantityDict

-- | Smart constructor for a <a>QuantityDict</a> from another
--   <a>Quantity</a> with units.
qw :: (Quantity q, MayHaveUnit q) => q -> QuantityDict

-- | Creates a <a>QuantityDict</a> from a <tt>UID</tt>, term (<a>NP</a>),
--   <a>Symbol</a>, and <a>Space</a>.
vc :: String -> NP -> Symbol -> Space -> QuantityDict

-- | Creates a <a>QuantityDict</a> from an <a>Idea</a>, <a>Symbol</a>, and
--   <a>Space</a>.
vc'' :: Idea c => c -> Symbol -> Space -> QuantityDict

-- | Similar to <a>vc</a>, but creates a <a>QuantityDict</a> from something
--   that knows about <a>Stage</a>s.
vcSt :: String -> NP -> (Stage -> Symbol) -> Space -> QuantityDict

-- | Creates a <a>QuantityDict</a> from a <tt>UID</tt>, term (<a>NP</a>),
--   <a>Symbol</a>, <a>Space</a>, and unit (<a>UnitDefn</a>).
vcUnit :: String -> NP -> Symbol -> Space -> UnitDefn -> QuantityDict
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Quantity.QuantityDict
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Quantity.QuantityDict
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Quantity.QuantityDict
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Quantity.QuantityDict
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Quantity.QuantityDict
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Quantity.QuantityDict
instance GHC.Classes.Eq Language.Drasil.Chunk.Quantity.QuantityDict
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Quantity.QuantityDict
instance Language.Drasil.DisplayClasses.Display Language.Drasil.Chunk.Quantity.QuantityDict

module Language.Drasil.Chunk.Unitary

-- | A Unitary is a <a>Quantity</a> that <b>must</b> have a unit.
class (Quantity c) => Unitary c
unit :: Unitary c => c -> UnitDefn

-- | UnitaryChunks are <a>Unitary</a>s with <tt>Symbols</tt>. Contains a
--   <a>QuantityDict</a> and a <a>UnitDefn</a>.
data UnitaryChunk

-- | Makes a <a>UnitaryChunk</a> from a quantity with a unit.
mkUnitary :: (Unitary u, MayHaveUnit u) => u -> UnitaryChunk

-- | Builds the <a>QuantityDict</a> part from the <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, and <a>Space</a>. Assumes there's no
--   abbreviation.
unitary :: IsUnit u => String -> NP -> Symbol -> u -> Space -> UnitaryChunk

-- | Same as <a>unitary</a> but with a <a>Symbol</a> that changes based on
--   the <a>Stage</a>.
unitary' :: IsUnit u => String -> NP -> (Stage -> Symbol) -> u -> Space -> UnitaryChunk

-- | Helper for getting the unit's <a>Symbol</a> from a chunk, as opposed
--   to the symbols of the chunk itself.
unit_symb :: Unitary c => c -> USymb
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Unitary.UnitaryChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Unitary.UnitaryChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Unitary.UnitaryChunk
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Unitary.UnitaryChunk
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Unitary.UnitaryChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Unitary.UnitaryChunk
instance Language.Drasil.Chunk.Unitary.Unitary Language.Drasil.Chunk.Unitary.UnitaryChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Unitary.UnitaryChunk

module Language.Drasil.Chunk.UnitaryConcept

-- | Constructs a UnitaryConceptDict from a <a>Concept</a> with
--   <tt>Units</tt>.
ucw :: (Unitary c, Concept c, MayHaveUnit c) => c -> UnitaryConceptDict

-- | Contains a <a>UnitaryChunk</a>, a definition, and a list of related
--   <a>UID</a>s.
data UnitaryConceptDict
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.UnitaryConcept.UnitaryConceptDict
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.UnitaryConcept.UnitaryConceptDict
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.UnitaryConcept.UnitaryConceptDict
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.UnitaryConcept.UnitaryConceptDict
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.UnitaryConcept.UnitaryConceptDict
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.UnitaryConcept.UnitaryConceptDict
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.UnitaryConcept.UnitaryConceptDict
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.UnitaryConcept.UnitaryConceptDict
instance GHC.Classes.Eq Language.Drasil.Chunk.UnitaryConcept.UnitaryConceptDict
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.UnitaryConcept.UnitaryConceptDict
instance Language.Drasil.Chunk.Unitary.Unitary Language.Drasil.Chunk.UnitaryConcept.UnitaryConceptDict

module Language.Drasil.Chunk.NamedArgument

-- | Any quantity can be a named argument (wrapper for <a>QuantityDict</a>)
newtype NamedArgument
NA :: QuantityDict -> NamedArgument
[_qtd] :: NamedArgument -> QuantityDict

-- | Smart constructor for <a>NamedArgument</a> .
narg :: (Quantity q, MayHaveUnit q) => q -> NamedArgument
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.NamedArgument.NamedArgument
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.NamedArgument.NamedArgument
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.NamedArgument.NamedArgument
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.NamedArgument.NamedArgument
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.NamedArgument.NamedArgument
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.NamedArgument.NamedArgument
instance Language.Drasil.Classes.IsArgumentName Language.Drasil.Chunk.NamedArgument.NamedArgument
instance GHC.Classes.Eq Language.Drasil.Chunk.NamedArgument.NamedArgument
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.NamedArgument.NamedArgument

module Language.Drasil.Chunk.Eq

-- | A QDefinition is a <a>QuantityDict</a> with a defining expression
--   (<a>Expr</a>), a definition (<a>Sentence</a>), and a domain
--   ([<a>UID</a>]).
data QDefinition

-- | Create a <a>QDefinition</a> with a <a>UID</a>, term (<a>NP</a>),
--   definition (<a>Sentence</a>), <a>Symbol</a>, <a>Space</a>, unit, and
--   defining expression.
fromEqn :: IsUnit u => String -> NP -> Sentence -> Symbol -> Space -> u -> Expr -> QDefinition

-- | Same as <a>fromEqn</a>, but has no units.
fromEqn' :: String -> NP -> Sentence -> Symbol -> Space -> Expr -> QDefinition

-- | Same as <a>fromEqn</a>, but symbol depends on stage.
fromEqnSt :: IsUnit u => String -> NP -> Sentence -> (Stage -> Symbol) -> Space -> u -> Expr -> QDefinition

-- | Same as <a>fromEqn</a>, but symbol depends on stage and has no units.
fromEqnSt' :: String -> NP -> Sentence -> (Stage -> Symbol) -> Space -> Expr -> QDefinition

-- | Wrapper for fromEqnSt and fromEqnSt'
mkQDefSt :: UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> Expr -> QDefinition

-- | Used to help make <a>QDefinition</a>s when <a>UID</a>, term, and
--   <a>Symbol</a> come from the same source.
mkQuantDef :: (Quantity c, MayHaveUnit c) => c -> Expr -> QDefinition

-- | Used to help make <a>QDefinition</a>s when <a>UID</a> and
--   <a>Symbol</a> come from the same source, with the term separate.
mkQuantDef' :: (Quantity c, MayHaveUnit c) => c -> NP -> Expr -> QDefinition

-- | Smart constructor for QDefinitions. Requires a quantity and its
--   defining equation.
ec :: (Quantity c, MayHaveUnit c) => c -> Expr -> QDefinition

-- | Create a <a>QDefinition</a> function with a symbol, name, term, list
--   of inputs, resultant units, and a defining Expr
mkFuncDef :: (HasUID f, HasSymbol f, HasSpace f, HasUID i, HasSymbol i, HasSpace i, IsUnit u) => f -> NP -> Sentence -> u -> [i] -> Expr -> QDefinition

-- | Create a <a>QDefinition</a> function with a symbol, name, term, list
--   of inputs, and a defining Expr
mkFuncDef' :: (HasUID f, HasSymbol f, HasSpace f, HasUID i, HasSymbol i, HasSpace i) => f -> NP -> Sentence -> [i] -> Expr -> QDefinition

-- | Create a <a>QDefinition</a> functions using a symbol, list of inputs,
--   and a defining Expr
mkFuncDefByQ :: (Quantity c, MayHaveUnit c, HasSpace c, Quantity i, HasSpace i) => c -> [i] -> Expr -> QDefinition
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Eq.QDefinition
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Eq.QDefinition
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Eq.QDefinition
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Eq.QDefinition
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Eq.QDefinition
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Eq.QDefinition
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Eq.QDefinition
instance Language.Drasil.Classes.DefiningExpr Language.Drasil.Chunk.Eq.QDefinition
instance GHC.Classes.Eq Language.Drasil.Chunk.Eq.QDefinition
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Eq.QDefinition
instance Language.Drasil.DisplayClasses.Display Language.Drasil.Chunk.Eq.QDefinition
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Eq.QDefinition

module Language.Drasil.Chunk.DefinedQuantity

-- | DefinedQuantityDict is the combination of a <a>Concept</a> and a
--   <a>Quantity</a>. Contains a <a>ConceptChunk</a>, a <a>Symbol</a>
--   dependent on <a>Stage</a>, a <a>Space</a>, and maybe a
--   <a>UnitDefn</a>.
data DefinedQuantityDict

-- | Smart constructor that creates a DefinedQuantityDict with a
--   <a>ConceptChunk</a>, a <a>Symbol</a> independent of <a>Stage</a>, a
--   <a>Space</a>, and a unit.
dqd :: IsUnit u => ConceptChunk -> Symbol -> Space -> u -> DefinedQuantityDict

-- | Similar to <a>dqd</a>, but without any units.
dqdNoUnit :: ConceptChunk -> Symbol -> Space -> DefinedQuantityDict

-- | Similar to <a>dqd</a>, but the <a>Symbol</a> is now dependent on the
--   <a>Stage</a>.
dqd' :: ConceptChunk -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> DefinedQuantityDict

-- | When we want to merge a quantity and a concept. This is suspicious.
dqdQd :: (Quantity c, MayHaveUnit c) => c -> ConceptChunk -> DefinedQuantityDict

-- | When the input already has all the necessary information. A
--   <tt>projection</tt> operator from some a type with instances of listed
--   classes to a <a>DefinedQuantityDict</a>.
dqdWr :: (Quantity c, Concept c, MayHaveUnit c) => c -> DefinedQuantityDict
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance GHC.Classes.Eq Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.DisplayClasses.Display Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict

module Language.Drasil.Chunk.Unital

-- | UnitalChunks are concepts with quantities and a unit definition.
--   Contains <a>DefinedQuantityDict</a>s and a <a>UnitDefn</a>.
data UnitalChunk
UC :: DefinedQuantityDict -> UnitDefn -> UnitalChunk
[_defq'] :: UnitalChunk -> DefinedQuantityDict
[_uni] :: UnitalChunk -> UnitDefn

-- | Creates a <a>UnitalChunk</a> in the same way as <a>uc'</a>, but with a
--   <a>Sentence</a> for the definition instead of a <a>String</a>.
makeUCWDS :: IsUnit u => String -> NP -> Sentence -> Symbol -> u -> UnitalChunk

-- | Used to create a <a>UnitalChunk</a> from a <a>Concept</a>,
--   <a>Symbol</a>, and <tt>Unit</tt>. Assumes the <a>Space</a> is Real.
uc :: (Concept c, IsUnit u) => c -> Symbol -> u -> UnitalChunk

-- | Similar to <a>uc</a>, except it builds the <a>Concept</a> portion of
--   the <a>UnitalChunk</a> from a given <tt>UID</tt>, term, and definition
--   (which are the first three arguments).
uc' :: IsUnit u => String -> NP -> String -> Symbol -> u -> UnitalChunk

-- | Similar to <a>uc'</a>, but <a>Symbol</a> is dependent on the
--   <a>Stage</a>.
ucStaged :: IsUnit u => String -> NP -> String -> (Stage -> Symbol) -> u -> UnitalChunk

-- | Similar to <a>uc'</a>, but does not assume the <a>Space</a>.
ucs :: IsUnit u => String -> NP -> String -> Symbol -> Space -> u -> UnitalChunk

-- | Similar to <a>uc</a> but does not assume the <a>Space</a>.
ucs' :: (Concept c, IsUnit u) => c -> Symbol -> Space -> u -> UnitalChunk

-- | Similar to <a>ucs</a>, but uses a <a>Sentence</a> for description.
ucsWS :: IsUnit u => String -> NP -> Sentence -> Symbol -> Space -> u -> UnitalChunk
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Chunk.Unitary.Unitary Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Unital.UnitalChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.DisplayClasses.Display Language.Drasil.Chunk.Unital.UnitalChunk

module Language.Drasil.Chunk.Constrained

-- | ConstrainedChunks are symbolic quantities (<a>QuantityDict</a>) with
--   <tt>Constraint</tt>s and maybe a typical value (<a>Maybe</a>
--   <a>Expr</a>).
data ConstrainedChunk
ConstrainedChunk :: QuantityDict -> [ConstraintE] -> Maybe Expr -> ConstrainedChunk
[_qd] :: ConstrainedChunk -> QuantityDict
[_constr] :: ConstrainedChunk -> [ConstraintE]
[_reasV] :: ConstrainedChunk -> Maybe Expr

-- | ConstrConcepts are conceptual symbolic quantities
--   (<a>DefinedQuantityDict</a>) with <tt>Constraint</tt>s and maybe a
--   reasonable value (no units!).
data ConstrConcept
ConstrConcept :: DefinedQuantityDict -> [ConstraintE] -> Maybe Expr -> ConstrConcept
[_defq] :: ConstrConcept -> DefinedQuantityDict
[_constr'] :: ConstrConcept -> [ConstraintE]
[_reasV'] :: ConstrConcept -> Maybe Expr

-- | Creates a new ConstrainedChunk from either a <a>ConstrainedChunk</a>,
--   <a>ConstrConcept</a>, <tt>UncertainChunk</tt>, or an <tt>UncertQ</tt>.
cnstrw :: (Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> ConstrainedChunk

-- | Similar to <a>cnstrw</a>, but types must also have a <a>Concept</a>.
cnstrw' :: (Quantity c, Concept c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> ConstrConcept

-- | Creates a <a>ConstrConcept</a> with a quantitative concept, a list of
--   <tt>Constraint</tt>s and an <a>Expr</a>.
constrained' :: (Concept c, MayHaveUnit c, Quantity c) => c -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to <a>constrained'</a>, but defaults <a>Maybe</a> <a>Expr</a>
--   to <a>Nothing</a>.
constrainedNRV' :: (Concept c, MayHaveUnit c, Quantity c) => c -> [ConstraintE] -> ConstrConcept

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, unit, <a>Space</a>, <tt>Constraint</tt>s,
--   and an <a>Expr</a>.
cuc :: IsUnit u => String -> NP -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> ConstrainedChunk

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), description (<a>String</a>), <a>Symbol</a>, unit,
--   <a>Space</a>, <tt>Constraint</tt>s, and an <a>Expr</a>.
cuc' :: IsUnit u => String -> NP -> String -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to <a>cuc'</a>, but <a>Symbol</a> is dependent on
--   <a>Stage</a>.
cuc'' :: IsUnit u => String -> NP -> String -> (Stage -> Symbol) -> u -> Space -> [ConstraintE] -> Expr -> ConstrConcept

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, <a>Space</a>, <tt>Constraint</tt>s, and a
--   <a>Maybe</a> <a>Expr</a> (Similar to <a>cuc</a> but no units).
cvc :: String -> NP -> Symbol -> Space -> [ConstraintE] -> Maybe Expr -> ConstrainedChunk
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Constrained Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.HasReasVal Language.Drasil.Chunk.Constrained.ConstrConcept
instance GHC.Classes.Eq Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.DisplayClasses.Display Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Classes.Constrained Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Classes.HasReasVal Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Constrained.ConstrainedChunk

module Language.Drasil.Chunk.UncertainQuantity

-- | UncertQs are conceptual symbolic quantities with constraints and an
--   <a>Uncertainty</a>. Contains a <a>ConstrConcept</a> and an
--   <a>Uncertainty</a>.
data UncertQ

-- | UncertainChunk is a symbolic quantity with constraints, a typical
--   value, and an uncertainty. Contains a <a>ConstrainedChunk</a> and an
--   <a>Uncertainty</a>.
data UncertainChunk
UCh :: ConstrainedChunk -> Uncertainty -> UncertainChunk
[_conc] :: UncertainChunk -> ConstrainedChunk
[_unc'] :: UncertainChunk -> Uncertainty

-- | Smart constructor that requires a <a>Quantity</a>, a percentage, and a
--   typical value with an <a>Uncertainty</a>.
uq :: (Quantity c, Constrained c, Concept c, HasReasVal c, MayHaveUnit c) => c -> Uncertainty -> UncertQ

-- | Uncertainty quantity (<a>uq</a>) but with a constraint.
uqc :: IsUnit u => String -> NP -> String -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertQ

-- | Uncertainty quantity constraint (<a>uqc</a>) without a description.
uqcND :: IsUnit u => String -> NP -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertQ

-- | Smart constructor that can project to an <a>UncertainChunk</a> (also
--   given an <a>Uncertainty</a>).
uncrtnChunk :: (Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> Uncertainty -> UncertainChunk

-- | Creates an uncertain variable chunk. Takes <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, <a>Space</a>, <tt>Constrains</tt>,
--   <a>Expr</a>, and <a>Uncertainty</a>.
uvc :: String -> NP -> Symbol -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertainChunk

-- | Projection function into an <a>UncertainChunk</a> from <a>UncertQ</a>
--   or an <a>UncertainChunk</a>.
uncrtnw :: (HasUncertainty c, Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> UncertainChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.HasUncertainty Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Constrained Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.HasReasVal Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.DisplayClasses.Display Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.Constrained Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.HasReasVal Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.HasUncertainty Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.UncertainQuantity.UncertainChunk

module Language.Drasil

-- | Drasil expressions.
data Expr

-- | Turns a decimal value (<a>Double</a>) into an expression.
[Dbl] :: Double -> Expr

-- | Turns an integer into an expression.
[Int] :: Integer -> Expr

-- | Represents decimal values that are exact as integers.
[ExactDbl] :: Integer -> Expr

-- | Turns a string into an expression.
[Str] :: String -> Expr

-- | Turns two integers into a fraction (or percent).
[Perc] :: Integer -> Integer -> Expr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [Expr] -> Expr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [Expr] -> Expr

-- | Derivative syntax is: Type (<a>Part</a>ial or <a>Total</a>) -&gt;
--   principal part of change -&gt; with respect to For example: Deriv Part
--   y x1 would be (dy/dx1).
[Deriv] :: DerivType -> Expr -> UID -> Expr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> Expr

-- | A function call accepts a list of parameters and a list of named
--   parameters. For example
--   
--   <ul>
--   <li>F(x) is (FCall F [x] []).</li>
--   <li>F(x,y) would be (FCall F [x,y]).</li>
--   <li>F(x,n=y) would be (FCall F [x] [(n,y)]).</li>
--   </ul>
[FCall] :: UID -> [Expr] -> [(UID, Expr)] -> Expr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(Expr, Relation)] -> Expr

-- | Represents a matrix of expressions.
[Matrix] :: [[Expr]] -> Expr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> Expr -> Expr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> Expr -> Expr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> Expr -> Expr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> Expr -> Expr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> Expr -> Expr -> Expr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> Expr -> Expr -> Expr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> Expr -> Expr -> Expr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> Expr -> Expr -> Expr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> Expr -> Expr -> Expr

-- | Operators are generalized arithmetic operators over a
--   <a>DomainDesc</a> of an <a>Expr</a>. Could be called BigOp. ex:
--   Summation is represented via <tt>Add</tt> over a discrete domain.
[Operator] :: AssocArithOper -> DomainDesc Expr Expr -> Expr -> Expr

-- | A different kind of <tt>IsIn</tt>. A <a>UID</a> is an element of an
--   interval.
[RealI] :: UID -> RealInterval Expr Expr -> Expr

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp

-- | Equality operators (equal or not equal).
data EqBinOp

-- | Index operator.
data LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product).
data VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
AddI :: AssocArithOper
AddRe :: AssocArithOper
MulI :: AssocArithOper
MulRe :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper

-- | Determines the type of the derivative (either a partial derivative or
--   a total derivative).
data DerivType
Part :: DerivType
Total :: DerivType

-- | For case expressions (either complete or incomplete).
data Completeness
Complete :: Completeness
Incomplete :: Completeness

-- | A relation is just an expression (<a>Expr</a>).
type Relation = Expr

-- | Smart constructor for equating two expressions.
($=) :: Expr -> Expr -> Expr
infixr 4 $=

-- | Less than.
--   
--   Smart constructor for ordering two equations.
($<) :: Expr -> Expr -> Expr

-- | Less than or equal to.
--   
--   Smart constructor for ordering two equations.
($<=) :: Expr -> Expr -> Expr

-- | Greater than.
--   
--   Smart constructor for ordering two equations.
($>) :: Expr -> Expr -> Expr

-- | Greater than or equal to.
--   
--   Smart constructor for ordering two equations.
($>=) :: Expr -> Expr -> Expr

-- | Smart constructor for rasing the first expression to the power of the
--   second.
($^) :: Expr -> Expr -> Expr
infixr 8 $^

-- | Smart constructor for the boolean <i>and</i> operator.
($&&) :: Expr -> Expr -> Expr
infixr 9 $&&

-- | Smart constructor for the boolean <i>or</i> operator.
($||) :: Expr -> Expr -> Expr
infixr 9 $||

-- | Smart constructor to show that one expression implies the other
--   (conditional operator).
($=>) :: Expr -> Expr -> Expr

-- | Smart constructor to show that an expression exists if and only if
--   another expression exists (biconditional operator).
($<=>) :: Expr -> Expr -> Expr

-- | Smart constructor for the dot product of two equations.
($.) :: Expr -> Expr -> Expr

-- | Smart constructor for subtracting two expressions.
($-) :: Expr -> Expr -> Expr

-- | Smart constructor for dividing two expressions.
($/) :: Expr -> Expr -> Expr
infixl 7 $/

-- | Add two expressions (Integers).
addI :: Expr -> Expr -> Expr

-- | Add two expressions (Real numbers).
addRe :: Expr -> Expr -> Expr

-- | Multiply two expressions (Integers).
mulI :: Expr -> Expr -> Expr

-- | Multiply two expressions (Real numbers).
mulRe :: Expr -> Expr -> Expr

-- | Smart constructor for taking the absolute value of an expression.
abs_ :: Expr -> Expr

-- | Smart constructor for negating an expression.
neg :: Expr -> Expr

-- | Smart constructor for negating vectors.
negVec :: Expr -> Expr

-- | Smart constructor to take the log of an expression.
log :: Expr -> Expr

-- | Smart constructor to take the ln of an expression.
ln :: Expr -> Expr

-- | Absolute value.
abs :: Num a => a -> a

-- | Smart constructor to apply sin to an expression.
sin :: Expr -> Expr

-- | Smart constructor to apply cos to an expression.
cos :: Expr -> Expr

-- | Smart constructor to apply tan to an expression.
tan :: Expr -> Expr

-- | Smart constructor to apply sec to an expression.
sec :: Expr -> Expr

-- | Smart constructor to apply csc to an expression.
csc :: Expr -> Expr

-- | Smart constructor to apply cot to an expression.
cot :: Expr -> Expr

-- | Smart constructor to apply arcsin to an expression.
arcsin :: Expr -> Expr

-- | Smart constructor to apply arccos to an expression.
arccos :: Expr -> Expr

-- | Smart constructor to apply arctan to an expression.
arctan :: Expr -> Expr

-- | Smart constructor for the exponential (base e) function.
exp :: Expr -> Expr

-- | Smart constructor to take the square root of an expression.
sqrt :: Expr -> Expr

-- | Euclidean function : takes a vector and returns the sqrt of the
--   sum-of-squares.
euclidean :: [Expr] -> Expr

-- | Smart constructor for calculating the normal form of a vector.
norm :: Expr -> Expr

-- | Smart constructor for applying logical negation to an expression.
not_ :: Expr -> Expr

-- | Smart constructor to square a function.
square :: Expr -> Expr

-- | Smart constructor to half a function exactly.
half :: Expr -> Expr

-- | Constructs 1/2.
oneHalf :: Expr

-- | Constructs 1/3.
oneThird :: Expr

-- | Smart constructor for rational expressions (only in 1/x form).
recip_ :: Expr -> Expr

-- | Smart constructor for calculating the dimension of a vector.
dim :: Expr -> Expr

-- | Smart constructor for indexing.
idx :: Expr -> Expr -> Expr

-- | Smart constructor for integers.
int :: Integer -> Expr

-- | Smart constructor for doubles.
dbl :: Double -> Expr

-- | Smart constructor for exact doubles.
exactDbl :: Integer -> Expr

-- | Smart constructor for fractions.
frac :: Integer -> Integer -> Expr

-- | Smart constructor for strings.
str :: String -> Expr

-- | Smart constructors for percents.
perc :: Integer -> Integer -> Expr

-- | Smart constructor for case statement with complete set of cases.
completeCase :: [(Expr, Relation)] -> Expr

-- | Smart constructor for case statement with incomplete set of cases.
incompleteCase :: [(Expr, Relation)] -> Expr

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
sumAll :: Symbol -> Expr -> Expr

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defsum :: Symbol -> Expr -> Expr -> Expr -> Expr

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
prodAll :: Symbol -> Expr -> Expr

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defprod :: Symbol -> Expr -> Expr -> Expr -> Expr

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defint :: Symbol -> Expr -> Expr -> Expr -> Expr

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
intAll :: Symbol -> Expr -> Expr

-- | Smart constructor for 'real interval' membership.
realInterval :: HasUID c => c -> RealInterval Expr Expr -> Expr

-- | Gets the derivative of an <a>Expr</a> with respect to a <a>Symbol</a>.
deriv :: (HasUID c, HasSymbol c) => Expr -> c -> Expr

-- | Gets the derivative of an <a>Expr</a> with respect to a <a>Symbol</a>.
pderiv :: (HasUID c, HasSymbol c) => Expr -> c -> Expr

-- | Get an <a>Expr</a> from a <a>Symbol</a>.
sy :: (HasUID c, HasSymbol c) => c -> Expr

-- | Applies a given function with a list of parameters.
apply :: (HasUID f, HasSymbol f) => f -> [Expr] -> Expr

-- | Similar to <a>apply</a>, but converts second argument into
--   <a>Symbol</a>s.
apply1 :: (HasUID f, HasSymbol f, HasUID a, HasSymbol a) => f -> a -> Expr

-- | Similar to <a>apply</a>, but the applied function takes two parameters
--   (which are both <a>Symbol</a>s).
apply2 :: (HasUID f, HasSymbol f, HasUID a, HasSymbol a, HasUID b, HasSymbol b) => f -> a -> b -> Expr

-- | Similar to <a>apply</a>, but takes a relation to apply to
--   <a>FCall</a>.
applyWithNamedArgs :: (HasUID f, HasSymbol f, HasUID a, IsArgumentName a) => f -> [Expr] -> [(a, Expr)] -> Expr

-- | Smart constructor to cross product two expressions.
cross :: Expr -> Expr -> Expr

-- | Matrix helper function.
m2x2 :: Expr -> Expr -> Expr -> Expr -> Expr

-- | Matrix helper function.
vec2D :: Expr -> Expr -> Expr

-- | Matrix helper function.
dgnl2x2 :: Expr -> Expr -> Expr

-- | A variant of the expression language that allows for extensions of
--   Expr that wouldn't normally type check, or that we only care for
--   displaying.
data DisplayExpr

-- | One expression is "defined" by another.
defines :: (Display a, Display b) => a -> b -> DisplayExpr

-- | Bring a Space into the DisplayExpr.
spaceDE :: Space -> DisplayExpr
isIn :: Display a => a -> DisplayExpr -> DisplayExpr

-- | Binary associative <a>And</a>.
andDEs :: Display d => [d] -> DisplayExpr

-- | Binary associative <a>Equivalence</a>.
equivDEs :: Display a => [a] -> DisplayExpr

-- | Special characters include partial derivatives and the degree circle.
data Special
Partial :: Special
Circle :: Special

-- | Class for rendering special characters.
class RenderSpecial r
special :: RenderSpecial r => Special -> r

-- | A <tt>UID</tt> is a 'unique identifier' for things that we will put
--   into our database of information.
type UID = String

-- | The most basic item: having a unique identifier key, here a UID.
class HasUID c

-- | Provides a <i>unique</i> id for internal Drasil use.
uid :: HasUID c => Lens' c UID

-- | Members must have a reference address.
class HasRefAddress b

-- | Provides the ability to hold a reference address.
getRefAdd :: HasRefAddress b => b -> LblType

-- | A HasSymbol is anything which has a <a>Symbol</a>.
class HasSymbol c

-- | Provides the <a>Symbol</a> for a particular stage of generation.
symbol :: HasSymbol c => c -> Stage -> Symbol

-- | Members of this class have the ability to be referenced.
class (HasUID s, HasRefAddress s) => Referable s

-- | The referencing address (what we're linking to). Only visible in the
--   source (tex/html).
refAdd :: Referable s => s -> String

-- | Alternate form of reference.
renderRef :: Referable s => s -> LblType

-- | A <a>ShortName</a> is the text to be displayed for a link. Used for
--   referencing within a document that can include symbols and whatnot if
--   required. Visible in the typeset documents (pdf).
class HasShortName s
shortname :: HasShortName s => s -> ShortName

-- | <tt>Citation</tt>s should have a fields (<a>CiteField</a>).
class HasFields c

-- | Provides a <tt>Lens</tt> to <a>CiteField</a>s.
getFields :: HasFields c => Lens' c [CiteField]

-- | A NamedIdea is a <a>term</a> that we've identified (has a <a>UID</a>)
--   as being worthy of naming.
class HasUID c => NamedIdea c

-- | Lens to the term (a noun phrase).
term :: NamedIdea c => Lens' c NP

-- | Records any additional notes needed to avoid losing information
class HasAdditionalNotes c

-- | Provides a <tt>Lens</tt> to the notes.
getNotes :: HasAdditionalNotes c => Lens' c [Sentence]

-- | HasSpace is anything which has a <a>Space</a>.
class HasSpace c

-- | Provides a <tt>Lens</tt> to the <a>Space</a>.
typ :: HasSpace c => Lens' c Space

-- | Some chunks store a unit symbol.
class HasUnitSymbol u

-- | Provides the ability to hold a unit symbol (<a>USymb</a>).
usymb :: HasUnitSymbol u => u -> USymb

-- | A class that contains a list of <a>Reference</a>s.
class HasReference c

-- | Provides a <tt>Lens</tt> to the <a>Reference</a>s.
getReferences :: HasReference c => Lens' c [Reference]

-- | A class that contains a list of decorated references (<a>DecRef</a>s).
class HasDecRef c

-- | Provides a <tt>Lens</tt> to the <a>DecRef</a>s.
getDecRefs :: HasDecRef c => Lens' c [DecRef]

-- | A <a>Quantity</a> that could have a reasonable value.
class HasReasVal c

-- | Provides a <tt>Lens</tt> to the possible reasonable value.
reasVal :: HasReasVal c => Lens' c (Maybe Expr)

-- | A class that might have a <a>Derivation</a>.
class HasDerivation c

-- | Provides a <tt>Lens</tt> to a possible derivation.
derivations :: HasDerivation c => Lens' c (Maybe Derivation)

-- | An <a>Idea</a> is the combination of a <a>NamedIdea</a> and a
--   <a>CommonIdea</a>. In other words, it <i>may</i> have an
--   acronym/abbreviation.
class NamedIdea c => Idea c

-- | Gets the acronym/abbreviation.
getA :: Idea c => c -> Maybe String

-- | Defines a chunk.
class Definition c

-- | Provides (a <tt>Lens</tt> to) the definition for a chunk.
defn :: Definition c => Lens' c Sentence

-- | Some concepts have a domain (related information encoded in
--   <a>UID</a>s to other chunks).
class ConceptDomain c

-- | Provides Getter for the concept domain tags for a chunk
--   
--   <i>cdom</i> should be exported for use by the Drasil framework, but
--   should not be exported beyond that.
cdom :: ConceptDomain c => c -> [UID]

-- | Concepts are <a>Idea</a>s with definitions and domains.
type Concept c = (Idea c, Definition c, ConceptDomain c)

-- | Units are <a>Idea</a>s with a <a>Definition</a> which store a unit
--   symbol. They must also be explicitly declared to be instances of
--   IsUnit.
class (Idea u, Definition u, HasUnitSymbol u) => IsUnit u

-- | Holds units as a list of <a>UID</a>.
getUnits :: IsUnit u => u -> [UID]

-- | CommonIdea is a <a>NamedIdea</a> with the additional constraint that
--   it <b>must</b> have an abbreviation.
class NamedIdea c => CommonIdea c

-- | Introduces abrv which necessarily provides an abbreviation.
abrv :: CommonIdea c => c -> String

-- | The Constrained class is a <a>Quantity</a> that has value constraints.
--   It does not enforce <a>Quantity</a> at this point.
class Constrained c

-- | Provides a <tt>Lens</tt> to the <tt>Constraint</tt>s.
constraints :: Constrained c => Lens' c [ConstraintE]

-- | A better version of <tt>ExprRelat</tt> that holds an <a>Expr</a>.
class DefiningExpr c

-- | Provides a <tt>Lens</tt> to the expression.
defnExpr :: DefiningExpr c => Lens' c Expr

-- | Data that can convert into a Displayable <a>Expr</a>.
class Display c
toDispExpr :: Display c => c -> DisplayExpr

-- | HasUncertainty is just a chunk with some uncertainty associated to it.
--   This uncertainty is represented as a decimal value between 0 and 1
--   (percentage).
class HasUncertainty c

-- | Provides the <tt>Lens</tt> to an <a>Uncertainty</a>.
unc :: HasUncertainty c => Lens' c Uncertainty

-- | A Quantity is an <a>Idea</a> with a <a>Space</a> and a
--   <tt>Symbol</tt>. In theory, it should also restrict to being a part of
--   <tt>MayHaveUnit</tt>, but that causes all sorts of import cycles (or
--   lots of orphans).
class (Idea c, HasSpace c, HasSymbol c) => Quantity c

-- | Some chunks can be called like functions.
class (HasSymbol c) => Callable c

-- | Members must have a named argument.
class (HasSymbol c) => IsArgumentName c

-- | For projecting out to the <a>ConceptChunk</a> data-type.
cw :: Concept c => c -> ConceptChunk

-- | The ConceptChunk datatype is a Concept that contains an idea
--   (<a>IdeaDict</a>), a definition (<a>Sentence</a>), and a domain
--   ([<a>UID</a>]).
data ConceptChunk

-- | Contains a common idea (<a>CI</a>) with a definition
--   (<a>Sentence</a>).
data CommonConcept

-- | Contains a <a>ConceptChunk</a>, reference address, and a
--   <a>ShortName</a>.
data ConceptInstance

-- | Check if something has one domain. Throws an error if there is more
--   than one.
sDom :: [UID] -> UID

-- | The commonIdea smart constructor requires a chunk id (<a>UID</a>), a
--   term (<a>NP</a>), an abbreviation (<a>String</a>), and a domain
--   ([<a>UID</a>]).
commonIdea :: String -> NP -> String -> [UID] -> CI

-- | The common idea (with <tt>NounPhrase</tt>) data type. It must have a
--   <a>UID</a>, <tt>NounPhrase</tt> for its term, an abbreviation
--   (<a>String</a>), and a domain ([<a>UID</a>]).
data CI

-- | Get abbreviation in <a>Sentence</a> form from a <a>CI</a>.
getAcc :: CI -> Sentence

-- | Get abbreviation in <a>String</a> form from a <a>CI</a>.
getAccStr :: CI -> String

-- | Similar to <a>commonIdea</a>, but takes a list of <a>IdeaDict</a>
--   (often a domain).
commonIdeaWithDict :: String -> NP -> String -> [IdeaDict] -> CI

-- | Prepends the abbreviation from a <a>CommonIdea</a> to a <a>String</a>.
prependAbrv :: CommonIdea c => c -> String -> String

-- | Any quantity can be a named argument (wrapper for <a>QuantityDict</a>)
data NamedArgument

-- | Smart constructor for <a>NamedArgument</a> .
narg :: (Quantity q, MayHaveUnit q) => q -> NamedArgument

-- | Note that a <a>NamedChunk</a> does not have an acronym/abbreviation as
--   that's a <tt>CommonIdea</tt>, which has its own representation.
--   Contains a <a>UID</a> and a term (<a>NP</a>).
data NamedChunk

-- | Get short form (if it exists), else get term of an <a>Idea</a>.
short :: (Idea c, HasUID c) => c -> Sentence

-- | <a>NamedChunk</a> constructor, takes a <a>UID</a> and a term.
nc :: String -> NP -> NamedChunk

-- | <a>IdeaDict</a> is the canonical dictionary associated to <a>Idea</a>.
--   Contains a <a>NamedChunk</a> and maybe an abbreviation
--   (<a>String</a>). Don't export the record accessors.
data IdeaDict

-- | <a>IdeaDict</a> constructor, takes a <a>UID</a>, <a>NP</a>, and an
--   abbreviation in the form of <a>Maybe</a> <a>String</a>
mkIdea :: String -> NP -> Maybe String -> IdeaDict

-- | Historical name: nw comes from 'named wrapped' from when
--   <a>NamedIdea</a> exported <a>getA</a> (now in <a>Idea</a>). But there
--   are no more wrappers, instead we have explicit dictionaries. Unwraps
--   an <a>Idea</a> and places its <a>UID</a> and <a>NP</a> into an
--   <a>IdeaDict</a> with <a>Nothing</a> for an abbreviation.
nw :: Idea c => c -> IdeaDict

-- | Smart constructor for range of <a>Physical</a> constraints between two
--   given expressions.
physc :: RealInterval Expr Expr -> ConstraintE

-- | Smart constructor for range of <a>Software</a> constraints between two
--   given expressions.
sfwrc :: RealInterval Expr Expr -> ConstraintE

-- | Helpful for filtering for Physical constraints. True if constraint is
--   <a>Physical</a>.
isPhysC :: Constraint e -> Bool

-- | Helpful for filtering for Software constraints. True if constraint is
--   <a>Software</a>.
isSfwrC :: Constraint e -> Bool

-- | Holds constraints. May occur between an interval of <a>Expr</a>, a
--   list of <a>Double</a>s, or a list of <a>String</a>s.
data Constraint a

-- | By default, physical and software constraints are ranges.
[Range] :: ConstraintReason -> RealInterval a a -> Constraint a

-- | Type synonym for <a>ConstraintE</a>
type ConstraintE = Constraint Expr

-- | The reason behind the constraint's existence.
data ConstraintReason
Physical :: ConstraintReason
Software :: ConstraintReason

-- | ConstrainedChunks are symbolic quantities (<a>QuantityDict</a>) with
--   <tt>Constraint</tt>s and maybe a typical value (<a>Maybe</a>
--   <a>Expr</a>).
data ConstrainedChunk
ConstrainedChunk :: QuantityDict -> [ConstraintE] -> Maybe Expr -> ConstrainedChunk
[_qd] :: ConstrainedChunk -> QuantityDict
[_constr] :: ConstrainedChunk -> [ConstraintE]
[_reasV] :: ConstrainedChunk -> Maybe Expr

-- | ConstrConcepts are conceptual symbolic quantities
--   (<a>DefinedQuantityDict</a>) with <tt>Constraint</tt>s and maybe a
--   reasonable value (no units!).
data ConstrConcept
ConstrConcept :: DefinedQuantityDict -> [ConstraintE] -> Maybe Expr -> ConstrConcept
[_defq] :: ConstrConcept -> DefinedQuantityDict
[_constr'] :: ConstrConcept -> [ConstraintE]
[_reasV'] :: ConstrConcept -> Maybe Expr

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, unit, <a>Space</a>, <tt>Constraint</tt>s,
--   and an <a>Expr</a>.
cuc :: IsUnit u => String -> NP -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> ConstrainedChunk

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, <a>Space</a>, <tt>Constraint</tt>s, and a
--   <a>Maybe</a> <a>Expr</a> (Similar to <a>cuc</a> but no units).
cvc :: String -> NP -> Symbol -> Space -> [ConstraintE] -> Maybe Expr -> ConstrainedChunk

-- | Creates a <a>ConstrConcept</a> with a quantitative concept, a list of
--   <tt>Constraint</tt>s and an <a>Expr</a>.
constrained' :: (Concept c, MayHaveUnit c, Quantity c) => c -> [ConstraintE] -> Expr -> ConstrConcept

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), description (<a>String</a>), <a>Symbol</a>, unit,
--   <a>Space</a>, <tt>Constraint</tt>s, and an <a>Expr</a>.
cuc' :: IsUnit u => String -> NP -> String -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to <a>cuc'</a>, but <a>Symbol</a> is dependent on
--   <a>Stage</a>.
cuc'' :: IsUnit u => String -> NP -> String -> (Stage -> Symbol) -> u -> Space -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to <a>constrained'</a>, but defaults <a>Maybe</a> <a>Expr</a>
--   to <a>Nothing</a>.
constrainedNRV' :: (Concept c, MayHaveUnit c, Quantity c) => c -> [ConstraintE] -> ConstrConcept

-- | Creates a new ConstrainedChunk from either a <a>ConstrainedChunk</a>,
--   <a>ConstrConcept</a>, <tt>UncertainChunk</tt>, or an <tt>UncertQ</tt>.
cnstrw :: (Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> ConstrainedChunk

-- | Similar to <a>cnstrw</a>, but types must also have a <a>Concept</a>.
cnstrw' :: (Quantity c, Concept c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> ConstrConcept

-- | A QDefinition is a <a>QuantityDict</a> with a defining expression
--   (<a>Expr</a>), a definition (<a>Sentence</a>), and a domain
--   ([<a>UID</a>]).
data QDefinition

-- | Create a <a>QDefinition</a> with a <a>UID</a>, term (<a>NP</a>),
--   definition (<a>Sentence</a>), <a>Symbol</a>, <a>Space</a>, unit, and
--   defining expression.
fromEqn :: IsUnit u => String -> NP -> Sentence -> Symbol -> Space -> u -> Expr -> QDefinition

-- | Same as <a>fromEqn</a>, but has no units.
fromEqn' :: String -> NP -> Sentence -> Symbol -> Space -> Expr -> QDefinition

-- | Same as <a>fromEqn</a>, but symbol depends on stage.
fromEqnSt :: IsUnit u => String -> NP -> Sentence -> (Stage -> Symbol) -> Space -> u -> Expr -> QDefinition

-- | Same as <a>fromEqn</a>, but symbol depends on stage and has no units.
fromEqnSt' :: String -> NP -> Sentence -> (Stage -> Symbol) -> Space -> Expr -> QDefinition

-- | Wrapper for fromEqnSt and fromEqnSt'
mkQDefSt :: UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> Expr -> QDefinition

-- | Used to help make <a>QDefinition</a>s when <a>UID</a>, term, and
--   <a>Symbol</a> come from the same source.
mkQuantDef :: (Quantity c, MayHaveUnit c) => c -> Expr -> QDefinition

-- | Used to help make <a>QDefinition</a>s when <a>UID</a> and
--   <a>Symbol</a> come from the same source, with the term separate.
mkQuantDef' :: (Quantity c, MayHaveUnit c) => c -> NP -> Expr -> QDefinition

-- | Smart constructor for QDefinitions. Requires a quantity and its
--   defining equation.
ec :: (Quantity c, MayHaveUnit c) => c -> Expr -> QDefinition

-- | Create a <a>QDefinition</a> function with a symbol, name, term, list
--   of inputs, resultant units, and a defining Expr
mkFuncDef :: (HasUID f, HasSymbol f, HasSpace f, HasUID i, HasSymbol i, HasSpace i, IsUnit u) => f -> NP -> Sentence -> u -> [i] -> Expr -> QDefinition

-- | Create a <a>QDefinition</a> function with a symbol, name, term, list
--   of inputs, and a defining Expr
mkFuncDef' :: (HasUID f, HasSymbol f, HasSpace f, HasUID i, HasSymbol i, HasSpace i) => f -> NP -> Sentence -> [i] -> Expr -> QDefinition

-- | Create a <a>QDefinition</a> functions using a symbol, list of inputs,
--   and a defining Expr
mkFuncDefByQ :: (Quantity c, MayHaveUnit c, HasSpace c, Quantity i, HasSpace i) => c -> [i] -> Expr -> QDefinition

-- | QuantityDict is a combination of an <a>IdeaDict</a> with a quantity.
--   Contains an <a>IdeaDict</a>, <a>Space</a>, a function from
--   <a>Stage</a> -&gt; <a>Symbol</a>, and <a>Maybe</a> a <a>UnitDefn</a>.
data QuantityDict

-- | Smart constructor for a <a>QuantityDict</a> from another
--   <a>Quantity</a> with units.
qw :: (Quantity q, MayHaveUnit q) => q -> QuantityDict

-- | Make a <a>QuantityDict</a> from a <tt>UID</tt>, <a>NP</a>,
--   <a>Symbol</a>, <a>Space</a>, <a>Maybe</a> <a>UnitDefn</a>, and an
--   abbreviation (<a>Maybe</a> <a>String</a>).
mkQuant :: String -> NP -> Symbol -> Space -> Maybe UnitDefn -> Maybe String -> QuantityDict

-- | Similar to <a>mkQuant</a>, but the abbreviation is moved to the third
--   argument (<a>Maybe</a> <a>String</a>), and the <a>Symbol</a> is now
--   dependent on <a>Stage</a>.
mkQuant' :: String -> NP -> Maybe String -> Space -> (Stage -> Symbol) -> Maybe UnitDefn -> QuantityDict

-- | Makes a <a>QuantityDict</a> from an <a>Idea</a>, <a>Symbol</a>, and
--   <a>Space</a>. <a>Symbol</a> is implementation-only.
codeVC :: Idea c => c -> Symbol -> Space -> QuantityDict

-- | Makes a variable that is implementation-only.
implVar :: String -> NP -> Space -> Symbol -> QuantityDict

-- | Similar to <a>implVar</a> but allows specification of abbreviation and
--   unit.
implVar' :: String -> NP -> Maybe String -> Space -> Symbol -> Maybe UnitDefn -> QuantityDict

-- | Smart constructor for creating concept chunks given a <tt>UID</tt>,
--   <tt>NounPhrase</tt> (<a>NP</a>) and definition (as a <a>String</a>).
--   
--   Concept domain tagging is not yet implemented in this constructor.
dcc :: String -> NP -> String -> ConceptChunk

-- | Identical to <a>dcc</a>, but takes an abbreviation (<a>String</a>).
dcc' :: String -> NP -> String -> String -> CommonConcept

-- | Similar to <a>dcc</a>, except the definition takes a <a>Sentence</a>.
dccWDS :: String -> NP -> Sentence -> ConceptChunk

-- | Similar to <a>dcc</a>, except the definition is a <a>Sentence</a> and
--   takes an abbreviation (<a>String</a>).
dccWDS' :: String -> NP -> Sentence -> String -> CommonConcept

-- | Creates a <a>QuantityDict</a> from a <tt>UID</tt>, term (<a>NP</a>),
--   <a>Symbol</a>, and <a>Space</a>.
vc :: String -> NP -> Symbol -> Space -> QuantityDict

-- | Creates a <a>QuantityDict</a> from an <a>Idea</a>, <a>Symbol</a>, and
--   <a>Space</a>.
vc'' :: Idea c => c -> Symbol -> Space -> QuantityDict

-- | Similar to <a>vc</a>, but creates a <a>QuantityDict</a> from something
--   that knows about <a>Stage</a>s.
vcSt :: String -> NP -> (Stage -> Symbol) -> Space -> QuantityDict

-- | Creates a <a>QuantityDict</a> from a <tt>UID</tt>, term (<a>NP</a>),
--   <a>Symbol</a>, <a>Space</a>, and unit (<a>UnitDefn</a>).
vcUnit :: String -> NP -> Symbol -> Space -> UnitDefn -> QuantityDict

-- | Similar to <a>cc'</a>, but allows explicit tagging.
ccs :: (Idea c, Concept d) => c -> Sentence -> [d] -> ConceptChunk

-- | Constructor for <a>ConceptChunk</a>. Takes the definition of the
--   <a>ConceptChunk</a> as a <a>String</a>. Does not allow concept domain
--   tagging.
cc :: Idea c => c -> String -> ConceptChunk

-- | Same as <a>cc</a>, except definition is a <a>Sentence</a>.
cc' :: Idea c => c -> Sentence -> ConceptChunk

-- | Constructor for a <a>ConceptInstance</a>. Takes in the Reference
--   Address (<a>String</a>), a definition (<a>Sentence</a>), a short name
--   (<a>String</a>), and a domain (or explicit tagging).
cic :: Concept c => String -> Sentence -> String -> c -> ConceptInstance

-- | UncertainChunk is a symbolic quantity with constraints, a typical
--   value, and an uncertainty. Contains a <a>ConstrainedChunk</a> and an
--   <a>Uncertainty</a>.
data UncertainChunk
UCh :: ConstrainedChunk -> Uncertainty -> UncertainChunk
[_conc] :: UncertainChunk -> ConstrainedChunk
[_unc'] :: UncertainChunk -> Uncertainty

-- | UncertQs are conceptual symbolic quantities with constraints and an
--   <a>Uncertainty</a>. Contains a <a>ConstrConcept</a> and an
--   <a>Uncertainty</a>.
data UncertQ

-- | Smart constructor that requires a <a>Quantity</a>, a percentage, and a
--   typical value with an <a>Uncertainty</a>.
uq :: (Quantity c, Constrained c, Concept c, HasReasVal c, MayHaveUnit c) => c -> Uncertainty -> UncertQ

-- | Uncertainty quantity (<a>uq</a>) but with a constraint.
uqc :: IsUnit u => String -> NP -> String -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertQ

-- | Uncertainty quantity constraint (<a>uqc</a>) without a description.
uqcND :: IsUnit u => String -> NP -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertQ

-- | Smart constructor that can project to an <a>UncertainChunk</a> (also
--   given an <a>Uncertainty</a>).
uncrtnChunk :: (Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> Uncertainty -> UncertainChunk

-- | Creates an uncertain variable chunk. Takes <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, <a>Space</a>, <tt>Constrains</tt>,
--   <a>Expr</a>, and <a>Uncertainty</a>.
uvc :: String -> NP -> Symbol -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertainChunk

-- | Projection function into an <a>UncertainChunk</a> from <a>UncertQ</a>
--   or an <a>UncertainChunk</a>.
uncrtnw :: (HasUncertainty c, Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> UncertainChunk

-- | UnitalChunks are concepts with quantities and a unit definition.
--   Contains <a>DefinedQuantityDict</a>s and a <a>UnitDefn</a>.
data UnitalChunk
UC :: DefinedQuantityDict -> UnitDefn -> UnitalChunk
[_defq'] :: UnitalChunk -> DefinedQuantityDict
[_uni] :: UnitalChunk -> UnitDefn

-- | Creates a <a>UnitalChunk</a> in the same way as <a>uc'</a>, but with a
--   <a>Sentence</a> for the definition instead of a <a>String</a>.
makeUCWDS :: IsUnit u => String -> NP -> Sentence -> Symbol -> u -> UnitalChunk

-- | Used to create a <a>UnitalChunk</a> from a <a>Concept</a>,
--   <a>Symbol</a>, and <tt>Unit</tt>. Assumes the <a>Space</a> is Real.
uc :: (Concept c, IsUnit u) => c -> Symbol -> u -> UnitalChunk

-- | Similar to <a>uc</a>, except it builds the <a>Concept</a> portion of
--   the <a>UnitalChunk</a> from a given <tt>UID</tt>, term, and definition
--   (which are the first three arguments).
uc' :: IsUnit u => String -> NP -> String -> Symbol -> u -> UnitalChunk

-- | Similar to <a>uc'</a>, but <a>Symbol</a> is dependent on the
--   <a>Stage</a>.
ucStaged :: IsUnit u => String -> NP -> String -> (Stage -> Symbol) -> u -> UnitalChunk

-- | Similar to <a>uc'</a>, but does not assume the <a>Space</a>.
ucs :: IsUnit u => String -> NP -> String -> Symbol -> Space -> u -> UnitalChunk

-- | Similar to <a>uc</a> but does not assume the <a>Space</a>.
ucs' :: (Concept c, IsUnit u) => c -> Symbol -> Space -> u -> UnitalChunk

-- | Similar to <a>ucs</a>, but uses a <a>Sentence</a> for description.
ucsWS :: IsUnit u => String -> NP -> Sentence -> Symbol -> Space -> u -> UnitalChunk

-- | A Unitary is a <a>Quantity</a> that <b>must</b> have a unit.
class (Quantity c) => Unitary c
unit :: Unitary c => c -> UnitDefn

-- | UnitaryChunks are <a>Unitary</a>s with <tt>Symbols</tt>. Contains a
--   <a>QuantityDict</a> and a <a>UnitDefn</a>.
data UnitaryChunk

-- | Builds the <a>QuantityDict</a> part from the <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, and <a>Space</a>. Assumes there's no
--   abbreviation.
unitary :: IsUnit u => String -> NP -> Symbol -> u -> Space -> UnitaryChunk

-- | Same as <a>unitary</a> but with a <a>Symbol</a> that changes based on
--   the <a>Stage</a>.
unitary' :: IsUnit u => String -> NP -> (Stage -> Symbol) -> u -> Space -> UnitaryChunk

-- | Makes a <a>UnitaryChunk</a> from a quantity with a unit.
mkUnitary :: (Unitary u, MayHaveUnit u) => u -> UnitaryChunk

-- | Helper for getting the unit's <a>Symbol</a> from a chunk, as opposed
--   to the symbols of the chunk itself.
unit_symb :: Unitary c => c -> USymb

-- | For a <a>ConceptChunk</a> that also has a <a>Relation</a> attached.
data RelationConcept

-- | Create a <a>RelationConcept</a> from a given <a>UID</a>, term
--   (<a>NP</a>), definition (<a>Sentence</a>), and <a>Relation</a>.
makeRC :: UID -> NP -> Sentence -> Relation -> RelationConcept

-- | Create a new <a>RelationConcept</a> from an old <a>Concept</a>. Takes
--   a <a>Concept</a>, new <a>UID</a> and relation.
addRelToCC :: Concept c => c -> UID -> Relation -> RelationConcept

-- | DefinedQuantityDict is the combination of a <a>Concept</a> and a
--   <a>Quantity</a>. Contains a <a>ConceptChunk</a>, a <a>Symbol</a>
--   dependent on <a>Stage</a>, a <a>Space</a>, and maybe a
--   <a>UnitDefn</a>.
data DefinedQuantityDict

-- | Smart constructor that creates a DefinedQuantityDict with a
--   <a>ConceptChunk</a>, a <a>Symbol</a> independent of <a>Stage</a>, a
--   <a>Space</a>, and a unit.
dqd :: IsUnit u => ConceptChunk -> Symbol -> Space -> u -> DefinedQuantityDict

-- | Similar to <a>dqd</a>, but the <a>Symbol</a> is now dependent on the
--   <a>Stage</a>.
dqd' :: ConceptChunk -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> DefinedQuantityDict

-- | Similar to <a>dqd</a>, but without any units.
dqdNoUnit :: ConceptChunk -> Symbol -> Space -> DefinedQuantityDict

-- | When we want to merge a quantity and a concept. This is suspicious.
dqdQd :: (Quantity c, MayHaveUnit c) => c -> ConceptChunk -> DefinedQuantityDict

-- | When the input already has all the necessary information. A
--   <tt>projection</tt> operator from some a type with instances of listed
--   classes to a <a>DefinedQuantityDict</a>.
dqdWr :: (Quantity c, Concept c, MayHaveUnit c) => c -> DefinedQuantityDict

-- | Constructs a UnitaryConceptDict from a <a>Concept</a> with
--   <tt>Units</tt>.
ucw :: (Unitary c, Concept c, MayHaveUnit c) => c -> UnitaryConceptDict

-- | Contains a <a>UnitaryChunk</a>, a definition, and a list of related
--   <a>UID</a>s.
data UnitaryConceptDict

-- | Derivations are an ordered list of sentences and expressions. They are
--   rendered in order as paragraphs and equation blocks to display the
--   derivation.
data Derivation
Derivation :: Sentence -> [Sentence] -> Derivation

-- | Smart constructor for creating a <a>Derivation</a>.
mkDeriv :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but prepends "Detailed derivation of" to
--   the header.
mkDerivName :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but without a header <a>Sentence</a>.
mkDerivNoHeader :: [Sentence] -> Derivation

-- | Used for holding the short form of a name (as a String with a
--   wrapper).
data ShortName

-- | Smart constructor for making a <a>String</a> into a <a>ShortName</a>.
shortname' :: Sentence -> ShortName

-- | Pulls the short form (as a <a>String</a>) out of a <a>ShortName</a>.
getSentSN :: ShortName -> Sentence

-- | All citations require a unique identifier used by the Drasil chunk. We
--   will re-use the <a>UID</a> part as an EntryID (<a>String</a>) used for
--   creating reference links. Finally we will have the reference
--   information (<a>CitationKind</a>, <a>CiteField</a>s, and a
--   <a>ShortName</a>).
data Citation
type EntryID = String " A 'String' that should contain no spaces."
type BibRef = [Citation] " A list of 'Citation's."
citeID :: Lens' Citation UID
citeKind :: Lens' Citation CitationKind

-- | Article citation requires author(s), title, journal, year. Optional
--   fields can be: volume, number, pages, month, and note. Implicitly uses
--   the EntryID as the chunk id.
cArticle :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by author.
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk id.
cBookA :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by editor.
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk id.
cBookE :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Booklet citation requires title. Optional fields can be author, how
--   published, address, month, year, note. Implicitly uses the EntryID as
--   the chunk id.
cBooklet :: String -> [CiteField] -> String -> Citation

-- | InBook citation by author.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id. This smart constructor includes both chapter
--   and page numbers.
cInBookACP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InBook citation by editor.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id. This smart constructor includes both chapter
--   and page numbers.
cInBookECP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookACP</a>.
--   
--   InBook citation excluding page numbers.
cInBookAC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookECP</a>.
--   
--   InBook citation excluding page numbers.
cInBookEC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookACP</a>.
--   
--   InBook citation excluding chapter.
cInBookAP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookECP</a>.
--   
--   InBook citation excluding chapter.
cInBookEP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InCollection citation requires author, title, bookTitle, publisher,
--   year. Optional fields can be editor, volume or number, series, type,
--   chapter, pages, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id.
cInCollection :: People -> String -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | InProceedings citation requires author, title, bookTitle, year.
--   Optional fields can be editor, volume or number, series, pages,
--   address, month, organization, publisher, and note. Implicitly uses the
--   EntryID as the chunk id.
cInProceedings :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Manual (technical documentation) citation requires title. Optional
--   fields can be author, organization, address, edition, month, year, and
--   note. Implicitly uses the EntryID as the chunk id.
cManual :: String -> [CiteField] -> String -> Citation

-- | Master's Thesis citation requires author, title, school, and year.
--   Optional fields can be type, address, month, and note. Implicitly uses
--   the EntryID as the chunk id.
cMThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Misc citation requires nothing. Optional fields can be author, title,
--   howpublished, month, year, and note. Implicitly uses the EntryID as
--   the chunk id.
cMisc :: [CiteField] -> String -> Citation

-- | PhD Thesis citation requires author, title, school, and year. Optional
--   fields can be type, address, month, and note. Implicitly uses the
--   EntryID as the chunk id.
cPhDThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Proceedings citation requires title and year. Optional fields can be
--   editor, volume or number, series, address, publisher, note, month, and
--   organization. Implicitly uses the EntryID as the chunk id.
cProceedings :: String -> Int -> [CiteField] -> String -> Citation

-- | Technical Report citation requires author, title, institution, and
--   year. Optional fields can be type, number, address, month, and note.
--   Implicitly uses the EntryID as the chunk id.
cTechReport :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Unpublished citation requires author, title, and note. Optional fields
--   can be month and year. Implicitly uses the EntryID as the chunk id.
cUnpublished :: People -> String -> String -> [CiteField] -> String -> Citation

-- | Some documents, as well as some pieces of knowledge, have citations.
class HasCitation c

-- | Provides a <tt>Lens</tt> to the citations.
getCitations :: HasCitation c => Lens' c [Citation]

-- | For writing <a>Sentence</a>s via combining smaller elements.
--   <a>Sentence</a>s are made up of some known vocabulary of things:
--   
--   <ul>
--   <li>units (their visual representation)</li>
--   <li>words (via <a>String</a>s)</li>
--   <li>special characters</li>
--   <li>accented letters</li>
--   <li>references to specific layout objects</li>
--   </ul>
data Sentence

-- | Ch looks up the term for a given <a>UID</a> and displays the term with
--   a given <a>SentenceStyle</a> and <tt>CapitalizationRule</tt>. This
--   allows Sentences to hold plural forms of <tt>NounPhrase</tt>s and
--   <tt>NamedIdea</tt>s.
[Ch] :: SentenceStyle -> TermCapitalization -> UID -> Sentence

-- | A branch of Ch dedicated to SymbolStyle only.
[SyCh] :: UID -> Sentence

-- | Converts a unit symbol into a usable Sentence form.
[Sy] :: USymb -> Sentence

-- | Constructor for <a>String</a>s, used often for descriptions in Chunks.
[S] :: String -> Sentence

-- | Converts the graphical representation of a symbol into a usable
--   Sentence form.
[P] :: Symbol -> Sentence

-- | Lifts an expression into a Sentence.
[E] :: DisplayExpr -> Sentence

-- | Takes a <a>UID</a> to a reference, a display name (<a>Sentence</a>),
--   and any additional reference display information (<a>RefInfo</a>).
--   Resolves the reference later (similar to Ch).
[Ref] :: UID -> Sentence -> RefInfo -> Sentence

-- | Adds quotation marks around a Sentence.
[Quote] :: Sentence -> Sentence

-- | Used for a % symbol.
[Percent] :: Sentence

-- | Direct concatenation of two Sentences (no implicit spaces!).
[:+:] :: Sentence -> Sentence -> Sentence

-- | Empty Sentence.
[EmptyS] :: Sentence
infixr 5 :+:

-- | Used in <a>Ch</a> constructor to determine the state of a term (can
--   record whether something is in plural form, a singular term, or in
--   short form).
data SentenceStyle
PluralTerm :: SentenceStyle
TermStyle :: SentenceStyle
ShortStyle :: SentenceStyle

-- | Used in <a>Ch</a> constructor to determine the capitalization of a
--   term. CapF is for capitalizing the first word from the <a>UID</a> of
--   the given term. CapW is for capitalizing all words from the <a>UID</a>
--   of the given term. Mirrors <tt>CapFirst</tt> and <tt>CapWords</tt>
--   from <tt>CapitalizationRule</tt>.
data TermCapitalization
CapF :: TermCapitalization
CapW :: TermCapitalization
NoCap :: TermCapitalization

-- | Holds any extra information needed for a <tt>Reference</tt>, be it an
--   equation, pages, a note, or nothing.
data RefInfo
None :: RefInfo
Equation :: [Int] -> RefInfo
Page :: [Int] -> RefInfo
RefNote :: String -> RefInfo

-- | Helper for concatenating two <a>Sentence</a>s with a space between
--   them.
(+:+) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two <a>Sentence</a>s using <a>+:+</a> and
--   appends a period.
(+:+.) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two sentences using <a>+:+</a> and appends a
--   colon.
(+:) :: Sentence -> Sentence -> Sentence

-- | Helper which appends a period to the end of a <a>Sentence</a> (used
--   often as a post-fix operator).
(!.) :: Sentence -> Sentence

-- | Capitalizes a Sentence.
capSent :: Sentence -> Sentence

-- | Gets a symbol and places it in a <a>Sentence</a>.
ch :: (HasUID c, HasSymbol c) => c -> Sentence
eS :: Display d => d -> Sentence

-- | Helper for concatenating two <a>Sentence</a>s with a comma and space
--   between them.
sC :: Sentence -> Sentence -> Sentence

-- | Helper for concatenating two <a>Sentence</a>s with a space-surrounded
--   dash between them.
sDash :: Sentence -> Sentence -> Sentence

-- | Helper for wrapping <a>Sentence</a>s in parentheses.
sParen :: Sentence -> Sentence

-- | This is to collect <i>symbolic</i> <a>UID</a>s that are printed out as
--   a <tt>Symbol</tt>.
sdep :: Sentence -> [UID]
shortdep :: Sentence -> [UID]
class NounPhrase n

-- | Retrieves singular form of term. Ex. "the quick brown fox".
phraseNP :: NounPhrase n => n -> Sentence

-- | Retrieves plural form of term. Ex. "the quick brown foxes".
pluralNP :: NounPhrase n => n -> PluralForm

-- | Retrieves the singular form and applies a captalization rule (usually
--   capitalizes the first word) to produce a <a>Sentence</a>. Ex. "The
--   quick brown fox".
sentenceCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization

-- | Retrieves the singular form and applies a captalization rule (usually
--   capitalizes all words) to produce a <a>Sentence</a>. Ex. "The Quick
--   Brown Fox".
titleCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization

-- | For nouns and <tt>NounPhrase</tt>s. May be constructed from a proper
--   noun, common noun, or phrase (<a>Sentence</a>) and their respective
--   pluralization and capitalization rules.
data NP

-- | Self plural.
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn :: String -> NP

-- | Plural form simply adds "s" (ex. Henderson -&gt; Hendersons).
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn' :: String -> NP

-- | Plural form adds "e".
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn'' :: String -> NP

-- | Plural form adds "es" (ex. Bush -&gt; Bushes).
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn''' :: String -> NP

-- | Constructs a <a>ProperNoun</a> with a custom plural rule (using
--   <a>IrregPlur</a> from <a>PluralRule</a>). First argument is the String
--   representing the noun, second is the rule.
pnIrr :: String -> PluralRule -> NP

-- | Self plural.
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn :: String -> NP

-- | Plural form simply adds "s" (ex. dog -&gt; dogs).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn' :: String -> NP

-- | Plural form adds "e" (ex. formula -&gt; formulae).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn'' :: String -> NP

-- | Plural form adds "es" (ex. bush -&gt; bushes).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn''' :: String -> NP

-- | Constructs a common noun that allows you to specify the pluralization
--   rule (as in <a>pnIrr</a>).
cnIP :: String -> PluralRule -> NP

-- | Common noun that allows you to specify both the pluralization rule and
--   the capitalization rule for sentence case (if the noun is used at the
--   beginning of a sentence).
cnIrr :: String -> PluralRule -> CapitalizationRule -> NP

-- | Constructs a common noun that pluralizes by dropping the last letter
--   and adding an "ies" ending (ex. body -&gt; bodies).
cnIES :: String -> NP

-- | Construct a common noun that pluralizes by dropping the last two
--   letters and adding an "ices" ending (ex. matrix -&gt; matrices).
cnICES :: String -> NP

-- | Constructs a common noun that pluralizes by dropping the last two
--   letters and adding "es" (ex. analysis -&gt; analyses).
cnIS :: String -> NP

-- | Constructs a common noun that pluralizes by dropping the last two
--   letters and adding "a" (ex. datum -&gt; data).
cnUM :: String -> NP

-- | Creates a <a>NP</a> with a given singular and plural form (as
--   <a>String</a>s) that capitalizes the first letter of the first word
--   for sentence case.
nounPhrase :: String -> PluralString -> NP

-- | Similar to <a>nounPhrase</a>, but takes a specified capitalization
--   rule for the sentence case.
nounPhrase' :: String -> PluralString -> CapitalizationRule -> NP

-- | Capitalization rules.
data CapitalizationRule

-- | Capitalize the first letter of the first word only.
CapFirst :: CapitalizationRule

-- | Capitalize the first letter of each word.
CapWords :: CapitalizationRule

-- | Replace the noun phrase with the given <a>Sentence</a>. Used for
--   custom capitalization.
Replace :: Sentence -> CapitalizationRule

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
atStartNP :: NounPhrase n => n -> Capitalization

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
atStartNP' :: NounPhrase n => n -> Capitalization

-- | Pluralization rules.
data PluralRule

-- | Add "s" to the end of the noun phrase.
AddS :: PluralRule

-- | Add "e" to the end of the noun phrase.
AddE :: PluralRule

-- | Add "es" to the end of the noun phrase.
AddES :: PluralRule

-- | The noun phrase is already plural.
SelfPlur :: PluralRule

-- | Apply the given function to the noun phrase to get the plural.
IrregPlur :: (String -> String) -> PluralRule

-- | Combine two noun phrases. The singular form becomes <tt>phrase</tt>
--   from t1 followed by <tt>phrase</tt> of t2. The plural becomes
--   <tt>phrase</tt> of t1 followed by <tt>plural</tt> of t2. Uses standard
--   <a>CapFirst</a> sentence case and <a>CapWords</a> title case. For
--   example: <tt>compoundPhrase system constraint</tt> will have singular
--   form "system constraint" and plural "system constraints".
compoundPhrase :: (NounPhrase a, NounPhrase b) => a -> b -> NP

-- | Similar to <a>compoundPhrase</a>, but the sentence case is the same as
--   the title case (<a>CapWords</a>).
compoundPhrase' :: NP -> NP -> NP

-- | Similar to <a>compoundPhrase'</a>, but accepts two functions that will
--   be used to construct the plural form. For example,
--   <tt>compoundPhrase'' plural phrase system constraint</tt> would have
--   the plural form "systems constraint".
compoundPhrase'' :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Similar to <a>compoundPhrase</a>, but used when you need a special
--   function applied to the first term of both singular and pluralcases
--   (eg. short or plural).
compoundPhrase''' :: (NP -> Sentence) -> NP -> NP -> NP

-- | Similar to <a>compoundPhrase</a>, but pluralizes the first <a>NP</a>
--   for both singular and plural cases.
compoundPhraseP1 :: NP -> NP -> NP

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP :: NounPhrase n => n -> Capitalization

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP' :: NounPhrase n => n -> Capitalization

-- | Custom noun phrase constructor that takes a singular form
--   (<a>Sentence</a>), plural form (<a>Sentence</a>), sentence case
--   capitalization rule, and title case capitalization rule.
nounPhrase'' :: Sentence -> PluralForm -> CapitalizationRule -> CapitalizationRule -> NP

-- | For things that should not be pluralized (or are self-plural). Works
--   like <a>nounPhrase</a>, but with only the first argument.
nounPhraseSP :: String -> NP

-- | Similar to nounPhrase, except it only accepts one <a>Sentence</a>.
--   Used for Requirements, Assumptions, LikelyChanges, etc. to allow for
--   referencing. Plural case is just <a>AddS</a>.
nounPhraseSent :: Sentence -> NP

-- | A Document has a Title (<a>Sentence</a>), Author(s) (<a>Sentence</a>),
--   and <a>Section</a>s which hold the contents of the document.
data Document
Document :: Title -> Author -> ShowTableOfContents -> [Section] -> Document

-- | Determines whether or not the table of contents appears on the
--   generated artifacts.
data ShowTableOfContents
ToC :: ShowTableOfContents
NoToC :: ShowTableOfContents

-- | Types of definitions (general, instance, theory, or data).
data DType
General :: DType
Instance :: DType
Theory :: DType
Data :: DType

-- | Sections have a title (<a>Sentence</a>), a list of contents
--   (<a>SecCons</a>) and a shortname (<a>Reference</a>).
data Section
Section :: Title -> [SecCons] -> Reference -> Section
[tle] :: Section -> Title
[cons] :: Section -> [SecCons]
[_lab] :: Section -> Reference

-- | Contents may be labelled or unlabelled.
data Contents
UlC :: UnlabelledContent -> Contents
LlC :: LabelledContent -> Contents

-- | Section Contents are split into subsections or contents, where
--   contents are standard layout objects (see <a>Contents</a>).
data SecCons
Sub :: Section -> SecCons
Con :: Contents -> SecCons

-- | Denotes the different possible types that can be used as a list.
data ListType

-- | Bulleted list.
Bullet :: [(ItemType, Maybe String)] -> ListType

-- | Enumerated list.
Numeric :: [(ItemType, Maybe String)] -> ListType

-- | Simple list with items denoted by <tt>:</tt>. Renders as "Title: Item"
Simple :: [ListTuple] -> ListType

-- | Descriptive list, renders as "<b>Title: Item</b>" (see
--   <a>ListTuple</a>).
Desc :: [ListTuple] -> ListType

-- | Renders a list of "<tt><a>Title</a></tt> is the <tt>Item</tt>".
Definitions :: [ListTuple] -> ListType

-- | Denotes how something should behave in a list (<a>ListType</a>).
data ItemType

-- | Standard singular item.
Flat :: Sentence -> ItemType

-- | Nest a list (<a>ListType</a>) as an item.
Nested :: Header -> ListType -> ItemType
type ListTuple = (Title, ItemType, Maybe String) " Formats as Title: Item. For use in lists."

-- | Contains a <a>Reference</a> and <a>RawContent</a>.
data LabelledContent
LblC :: Reference -> RawContent -> LabelledContent
[_ref] :: LabelledContent -> Reference
[_ctype] :: LabelledContent -> RawContent

-- | Only contains <a>RawContent</a>.
newtype UnlabelledContent
UnlblC :: RawContent -> UnlabelledContent
[_cntnts] :: UnlabelledContent -> RawContent

-- | Smart constructor for retrieving the contents (<a>Section</a>s) from a
--   <a>Document</a>.
extractSection :: Document -> [Section]

-- | Smart constructor that wraps <a>UnlabelledContent</a> into
--   <a>Contents</a>.
mkParagraph :: Sentence -> Contents

-- | Smart constructor similar to <a>llcc</a>, but takes in
--   <a>RawContent</a> first.
mkRawLC :: RawContent -> Reference -> LabelledContent

-- | Manually removes the first section of a document (table of contents
--   section).
checkToC :: Document -> Document

-- | Smart constructor for labelled content chunks.
llcc :: Reference -> RawContent -> LabelledContent

-- | Smart constructor for unlabelled content chunks (no <a>Reference</a>).
ulcc :: RawContent -> UnlabelledContent

-- | Smart constructor for creating <a>Section</a>s with a title
--   (<a>Sentence</a>), introductory contents (ie. paragraphs, tables,
--   etc.), a list of subsections, and a shortname (<a>Reference</a>).
section :: Sentence -> [Contents] -> [Section] -> Reference -> Section

-- | <a>Figure</a> smart constructor with a <a>Lbl</a> and a
--   <a>Filepath</a>. Assumes 100% of page width as max width.
fig :: Lbl -> Filepath -> RawContent

-- | <a>Figure</a> smart constructor that allows for customized max widths.
figWithWidth :: Lbl -> Filepath -> MaxWidthPercent -> RawContent

-- | MaxWidthPercent should be kept in the range 1-100. Values outside this
--   range may have unexpected results. Used for specifying max figure
--   width as <tt>pagewidth*MaxWidthPercent/100</tt>.
type MaxWidthPercent = Float

-- | Members of this class must have <a>RawContent</a>.
class HasContents c

-- | Provides a <tt>Lens</tt> to the <a>RawContent</a>.
accessContents :: HasContents c => Lens' c RawContent

-- | Types of layout objects we deal with explicitly.
data RawContent

-- | table has: header-row, data(rows), label/caption, and a bool that
--   determines whether or not to show label.
Table :: [Sentence] -> [[Sentence]] -> Title -> Bool -> RawContent

-- | Paragraphs are just sentences.
Paragraph :: Sentence -> RawContent

-- | Block of Equations holds an expression.
EqnBlock :: DisplayExpr -> RawContent

-- | Grants the ability to label a group of <a>RawContent</a>.
DerivBlock :: Sentence -> [RawContent] -> RawContent

-- | For enumerated lists.
Enumeration :: ListType -> RawContent

-- | Defines something with a type, identifier, and <a>Contents</a>.
Defini :: DType -> [(Identifier, [Contents])] -> RawContent

-- | For creating figures in a document. Should use relative file path.
Figure :: Lbl -> Filepath -> MaxWidthPercent -> RawContent

-- | Grants the ability to reference something.
Bib :: BibRef -> RawContent

-- | Contain a graph with coordinates (<a>Sentence</a>s), maybe a width and
--   height, and a label (<a>Sentence</a>). TODO: Fill this one in.
Graph :: [(Sentence, Sentence)] -> Maybe Width -> Maybe Height -> Lbl -> RawContent

-- | Smart constructor that wraps <a>LabelledContent</a> into
--   <a>Contents</a>.
mkFig :: Reference -> RawContent -> Contents

-- | Create a reference for a table. Takes in the name of a table (which
--   will also be used for its shortname).
makeTabRef :: String -> Reference

-- | Create a reference for a figure. Takes in the name of a figure (which
--   will also be used for its shortname).
makeFigRef :: String -> Reference

-- | Create a reference for a section. Takes in the name of a section and a
--   shortname for the section.
makeSecRef :: String -> Sentence -> Reference

-- | Create a reference for a <a>URI</a>.
makeURI :: UID -> String -> ShortName -> Reference

-- | The difference kinds of spaces that may exist. This type holds
--   numerical spaces (such as the set of integers, rationals, etc.), a
--   space for booleans, a space for characters, dimensional spaces
--   (vectors, arrays, etc.), a space for Actors, discrete sets (both for
--   numbers and strings), and a void space.
data Space
Integer :: Space
Rational :: Space
Real :: Space
Natural :: Space
Boolean :: Space
Char :: Space
String :: Space
Radians :: Space
Vect :: Space -> Space
Array :: Space -> Space
Actor :: String -> Space
DiscreteD :: [Double] -> Space
DiscreteS :: [String] -> Space
Function :: NonEmpty Primitive -> Primitive -> Space
Void :: Space

-- | A RealInterval is a subset of <a>Real</a> (as a <a>Space</a>). These
--   come in different flavours. For now, we embed <tt>Expr</tt> for the
--   bounds, but that will change as well.
data RealInterval a b
[Bounded] :: (Inclusive, a) -> (Inclusive, b) -> RealInterval a b
[UpTo] :: (Inclusive, a) -> RealInterval a b
[UpFrom] :: (Inclusive, b) -> RealInterval a b

-- | Inclusitivity of a <a>Space</a>.
data Inclusive
Inc :: Inclusive
Exc :: Inclusive

-- | Topology of a subset of reals.
data RTopology
Continuous :: RTopology
Discrete :: RTopology

-- | Describes the domain of a <a>Symbol</a> given a topology. Can be
--   bounded or encase all of the domain.
data DomainDesc a b
[BoundedDD] :: Symbol -> RTopology -> a -> b -> DomainDesc a b
[AllDD] :: Symbol -> RTopology -> DomainDesc a b

-- | Gets the name of an <a>Actor</a>.
getActorName :: Space -> String

-- | Gets the inner <a>Space</a> of a vector.
getInnerSpace :: Space -> Space

-- | Decorations on symbols/characters such as hats or Vector
--   representations (determines bolding, italics, etc).
data Decoration

-- | A <a>Symbol</a> is actually going to be a graphical description of
--   what gets rendered as a (unique) symbol. This is actually NOT based on
--   semantics at all, but just a description of how things look.
--   
--   Symbols can be:
--   
--   <ul>
--   <li><tt><a>Variable</a></tt> (string such as "x" that represent a
--   value that can vary)</li>
--   <li><tt><a>Label</a></tt> (strings such as "max" or "target" that
--   represent a single idea)</li>
--   <li><tt><a>Special</a></tt> characters (ex. unicode)</li>
--   <li><tt>Decorated</tt> symbols</li>
--   <li><tt>Concatenations</tt> of symbols, including subscripts and
--   superscripts</li>
--   <li><tt><a>Empty</a></tt>! (this is to give this a monoid-like
--   flavour)</li>
--   </ul>
data Symbol

-- | Create a table body (not including header row) by applying the given
--   functions to the column elements of the table rows (in order). The
--   first argument is a list of functions to be applied (one per column).
--   This essentially creates the rows. The second argument is a list of
--   elements apply the functions to.
--   
--   For example, <tt>mkTable [id, *5] [1,2,3]</tt> should produce a table:
--   
--   <pre>
--   | 1 |  5 |
--   | 2 | 10 |
--   | 3 | 15 |
--   </pre>
mkTable :: [a -> b] -> [a] -> [[b]]

-- | People is a synonymn for many <a>Person</a>s.
type People = [Person]

-- | A person can have a given name, middle name(s), and surname, as well
--   as the naming convention they use.
data Person

-- | Constructor for a person using Western naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   given name, surname.
person :: String -> String -> Person

-- | Members of this class must have a name.
class HasName p

-- | Gets the name of a <a>Person</a>. Adds a dot after any initials.
name :: HasName n => n -> String

-- | Constructor for a person using Eastern naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   surname, given name.
person' :: String -> String -> Person

-- | Constructor for a person using Western naming conventions. Similar to
--   the <a>person</a> constructor, except the middle argument is a list of
--   middle names.
personWM :: String -> [String] -> String -> Person

-- | Constructor for a person using Eastern naming conventions. Similar to
--   the <a>person'</a> constructor, except the middle argument is a list
--   of middle names.
personWM' :: String -> [String] -> String -> Person

-- | Constructor for a person with a mononym (only one name).
mononym :: String -> Person

-- | Provides the ability to hold a name.
nameStr :: HasName p => p -> String

-- | Gets a <a>Person</a>'s name in the form: Last, First Middle.
rendPersLFM :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, F. M.
rendPersLFM' :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, First M.
rendPersLFM'' :: Person -> String

-- | Orderes different groups of <a>Person</a>s. If two lists are the same
--   up to a point, the citation with more <a>Person</a>s will go last.
comparePeople :: [Person] -> [Person] -> Ordering

-- | Stages correspond to what we're trying to look up. They range from
--   abstract to concrete. Equational stages are more theoretical and
--   oriented towards abstract design while the Implementation stages are
--   more oriented towards detailed design.
data Stage
Equational :: Stage
Implementation :: Stage

-- | Helper function for getting a symbol in the Equational Stage.
eqSymb :: HasSymbol q => q -> Symbol

-- | Helper function for getting a symbol in the Implementation Stage.
codeSymb :: HasSymbol q => q -> Symbol

-- | Finds if a <a>Stage</a> symbol is real or Empty. True if real.
hasStageSymbol :: HasSymbol q => q -> Stage -> Bool

-- | Helper for creating a symbol with Unicode in it.
autoStage :: Symbol -> Stage -> Symbol

-- | Helper for creating a symbol with a hat ("^") atop it.
hat :: Symbol -> Symbol

-- | Helper for creating a Vector symbol.
prime :: Symbol -> Symbol

-- | Helper for creating a symbol that depends on the stage.
staged :: Symbol -> Symbol -> Stage -> Symbol

-- | Helper for creating a symbol with a subscript to the right. Arguments:
--   Base symbol, then subscripted symbol.
sub :: Symbol -> Symbol -> Symbol

-- | Helper for a common case of subscript, with a string Arguments: Base
--   symbol, then subscript <a>String</a>.
subStr :: Symbol -> String -> Symbol

-- | Helper for creating a symbol with a superscript to the right.
--   Arguments: Base symbol, then superscripted symbol.
sup :: Symbol -> Symbol -> Symbol

-- | Helper for autoStage that applies unicodeString to all <a>Symbol</a>s
--   with <a>String</a>s.
unicodeConv :: Symbol -> Symbol

-- | Helper for creating a symbol with a superscript on the left side of
--   the symbol. Arguments: Base symbol, then superscripted symbol.
upperLeft :: Symbol -> Symbol -> Symbol

-- | Helper for creating a Vector symbol.
vec :: Symbol -> Symbol

-- | Label smart constructor, requires non-empty labels
label :: String -> Symbol

-- | Variable smart constructor, requires non-empty variables
variable :: String -> Symbol

-- | A Reference contains the identifier (<a>UID</a>), a reference address
--   (<a>LblType</a>), a human-readable shortname (<a>ShortName</a>), and
--   any extra information about the reference (<a>RefInfo</a>).
data Reference
Reference :: UID -> LblType -> ShortName -> Reference

-- | Finds the reference information of a <a>Reference</a>.
--   
--   Projector function that creates a <a>Reference</a> from something
--   <tt>Referable</tt>.
ref :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Reference

-- | Takes the reference <a>UID</a> and wraps it into a <a>Sentence</a>.
refS :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence

-- | Takes a <a>Reference</a> with a name to be displayed and wraps it into
--   a <a>Sentence</a>. Does not overwrite the shortname contained in the
--   reference, but will only display as the given <a>Sentence</a>.
namedRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence -> Sentence

-- | Takes a <a>Reference</a> with additional display info. Uses the
--   internal shortname for its display name.
complexRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> RefInfo -> Sentence

-- | Takes a <a>Reference</a> with a name to be displayed and any
--   additional information and wraps it into a <a>Sentence</a>. Does not
--   overwrite the shortname contained in the reference, but will only
--   display as the given <a>Sentence</a> along with the given
--   <a>RefInfo</a>.
namedComplexRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence -> RefInfo -> Sentence

-- | For holding a <a>Reference</a> that is decorated with extra
--   information (ex. page numbers, equation sources, etc.).
data DecRef

-- | For creating a decorated reference (<a>DecRef</a>) with extra
--   reference information (<a>RefInfo</a>).
dRefInfo :: (HasUID r, HasRefAddress r, HasShortName r) => r -> RefInfo -> DecRef

-- | Same as <a>ref</a>, but for <a>DecRef</a> instead of <a>Reference</a>.
dRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> DecRef

-- | Retrieves the <a>String</a> contained in a <a>LblType</a>.
getAdd :: LblType -> String

-- | Prepends a <a>String</a> to an <a>IRefProg</a>.
prepend :: String -> IRefProg

-- | Applying different pieces of information for a reference. An RP is a
--   decorated internal reference. Citation is a citation. URI is for URLs
--   and other external links.
data LblType
RP :: IRefProg -> String -> LblType
Citation :: String -> LblType
URI :: String -> LblType

-- | Created for different forms of references. Used in <a>LblType</a>.
data IRefProg

-- | Deferred lookup; done later. Used for domains in a
--   <tt>ConceptInstance</tt>.
Deferred :: UID -> IRefProg

-- | Lifts a <a>String</a> into a <tt>RefProg</tt>.
RS :: String -> IRefProg

-- | Concatenates with two subprograms.
RConcat :: IRefProg -> IRefProg -> IRefProg

-- | The <tt>Symbol</tt> to insert the <tt>ShortName</tt> directly.
Name :: IRefProg

-- | Helper for common pattern of introducing the title-case version of a
--   noun phrase (from an Idea) followed by its abbreviation in
--   parentheses.
introduceAbb :: Idea n => n -> Sentence

-- | Helper for getting the phrase from a <a>NamedIdea</a> using it's UID.
phrase :: (HasUID n, NamedIdea n) => n -> Sentence

-- | Helper for getting the plural of a phrase from a <a>NamedIdea</a>.
plural :: (HasUID n, NamedIdea n) => n -> Sentence

-- | Singular possesive function
--   
--   Helper for getting the possesive cases from the term of a
--   <a>NamedIdea</a>.
phrasePoss :: NamedIdea n => n -> Sentence

-- | Plural possesive function
--   
--   Helper for getting the possesive cases from the term of a
--   <a>NamedIdea</a>.
pluralPoss :: NamedIdea n => n -> Sentence

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   <a>NamedIdea</a>.
atStart :: NamedIdea n => n -> Sentence

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   <a>NamedIdea</a>.
atStart' :: NamedIdea n => n -> Sentence

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   <a>NamedIdea</a>.
titleize :: NamedIdea n => n -> Sentence

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   <a>NamedIdea</a>.
titleize' :: NamedIdea n => n -> Sentence

-- | Something that may contain an uncertainty value and a precision value.
data Uncertainty

-- | Smart constructor for values with uncertainty.
uncty :: Double -> Maybe Int -> Uncertainty

-- | The default uncertainty is set to 0.1.
defaultUncrt :: Uncertainty

-- | Accessor for uncertainty value from something that has an uncertainty.
uncVal :: HasUncertainty x => x -> Double

-- | Accessor for precision value from something that has an uncertainty.
uncPrec :: HasUncertainty x => x -> Maybe Int

-- | Smart constructor for exact values (no uncertainty).
exact :: Uncertainty

-- | Language of units (how to build them up into a unit symbol). Of the
--   form (<a>Symbol</a> ^ <a>Integer</a>). The <a>Integer</a> may be
--   negative, but should not be zero.
newtype USymb
US :: [(Symbol, Integer)] -> USymb

-- | Custom type for months (abbreviated).
data Month
Jan :: Month
Feb :: Month
Mar :: Month
Apr :: Month
May :: Month
Jun :: Month
Jul :: Month
Aug :: Month
Sep :: Month
Oct :: Month
Nov :: Month
Dec :: Month

-- | Fields used in citations.
data CiteField
Address :: String -> CiteField
Author :: People -> CiteField

-- | Used for <a>InCollection</a> references only.
BookTitle :: String -> CiteField
Chapter :: Int -> CiteField
Edition :: Int -> CiteField
Editor :: People -> CiteField

-- | Can be published via URL or something else.
HowPublished :: HP -> CiteField
Institution :: String -> CiteField
Journal :: String -> CiteField
Month :: Month -> CiteField
Note :: String -> CiteField
Number :: Int -> CiteField
Organization :: String -> CiteField

-- | Range of pages (ex1. 1-32; ex2. 7,31,52-55).
Pages :: [Int] -> CiteField
Publisher :: String -> CiteField
School :: String -> CiteField
Series :: String -> CiteField
Title :: String -> CiteField

-- | BibTeX "type" field.
Type :: String -> CiteField
Volume :: Int -> CiteField
Year :: Int -> CiteField

-- | How something is published. Necessary for URLs to work properly.
data HP
URL :: String -> HP
Verb :: String -> HP

-- | External references come in many flavours. Articles, Books, etc. (we
--   are using the types available in Bibtex).
data CitationKind
Article :: CitationKind
Book :: CitationKind
Booklet :: CitationKind
InBook :: CitationKind
InCollection :: CitationKind
InProceedings :: CitationKind
Manual :: CitationKind
MThesis :: CitationKind
Misc :: CitationKind
PhDThesis :: CitationKind
Proceedings :: CitationKind
TechReport :: CitationKind
Unpublished :: CitationKind

-- | Smart field constructor for a <a>CiteField</a>.
author :: People -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
editor :: People -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
address :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
bookTitle :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
howPublished :: String -> CiteField

-- | URL version of <a>howPublished</a>.
--   
--   Smart field constructor for a <a>CiteField</a>.
howPublishedU :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
institution :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
journal :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
note :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
organization :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
publisher :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
school :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
series :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
title :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
typeField :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
chapter :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
edition :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
number :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
volume :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
year :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
pages :: [Int] -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
month :: Month -> CiteField

-- | For defining units. It has a <a>ConceptChunk</a> (that defines what
--   kind of unit it is), a unit symbol, maybe another (when it is a
--   synonym), perhaps a definition, and a list of <a>UID</a> of the units
--   that make up the definition.
data UnitDefn
UD :: ConceptChunk -> UnitSymbol -> [UID] -> UnitDefn
[_vc] :: UnitDefn -> ConceptChunk
[_cas] :: UnitDefn -> UnitSymbol
[_cu] :: UnitDefn -> [UID]

-- | Generates a default unit symbol.
fromUDefn :: UDefn -> USymb

-- | Helper for fundamental unit concept chunk creation. Uses the same
--   <a>String</a> for the identifier, term, and definition.
unitCon :: String -> ConceptChunk

-- | Create a derived unit chunk from a concept and a unit equation.
makeDerU :: ConceptChunk -> UnitEquation -> UnitDefn

-- | Combinator for raising a unit to a power.
(^:) :: UnitDefn -> Integer -> UnitEquation

-- | Combinator for dividing one unit by another.
(/:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying two units together.
(*:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying a unit and a symbol.
(*$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for dividing a unit and a symbol.
(/$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for mulitiplying two unit equations.
(^$) :: UnitEquation -> UnitEquation -> UnitEquation

-- | Smart constructor for new derived units from existing units.
newUnit :: String -> UnitEquation -> UnitDefn

-- | Combinator for scaling one unit by some number.
scale :: IsUnit s => Double -> s -> UDefn

-- | Combinator for shifting one unit by some number.
shift :: IsUnit s => Double -> s -> UDefn

-- | Uses self-plural term.
--   
--   Create a derived unit chunk from a <a>UID</a>, term (<a>String</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Uses term that pluralizes by adding "s" to the end.
--   
--   Create a derived unit chunk from a <a>UID</a>, term (<a>String</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC' :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Create a derived unit chunk from a <a>UID</a>, term (<a>NP</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC'' :: String -> NP -> String -> Symbol -> UDefn -> UnitDefn

-- | Smart constructor for a "fundamental" unit.
fund :: String -> String -> String -> UnitDefn

-- | Variant of the <a>fund</a>, useful for degree.
fund' :: String -> String -> Symbol -> UnitDefn

-- | We don't want an Ord on units, but this still allows us to compare
--   them.
compUnitDefn :: UnitDefn -> UnitDefn -> Ordering

-- | Create a <tt>SI_Unit</tt> with two <a>Symbol</a> representations. The
--   created <a>NP</a> is self-plural.
derCUC :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Similar to <a>derCUC</a>, but the created <a>NP</a> has the
--   <tt>AddS</tt> plural rule.
derCUC' :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Create a derived unit chunk from a <a>UID</a>, term (<a>NP</a>),
--   definition, <a>Symbol</a>, and unit equation.
derCUC'' :: String -> NP -> String -> Symbol -> UnitEquation -> UnitDefn

-- | For allowing lists to mix the two, thus forgetting the definition
--   part.
unitWrapper :: IsUnit u => u -> UnitDefn

-- | Get a list of <a>UID</a> of the units that make up the
--   <a>UnitEquation</a>.
getCu :: UnitEquation -> [UID]

-- | Types may contain a unit (<a>UnitDefn</a>).
class MayHaveUnit u
getUnit :: MayHaveUnit u => u -> Maybe UnitDefn
